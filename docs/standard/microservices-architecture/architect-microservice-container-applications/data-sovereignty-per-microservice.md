---
title: マイクロサービス単位のデータ管理
description: マイクロサービスのキー ポイントの 1 つは、マイクロサービス単位でのデータ管理です。 各マイクロサービスは、他とそのデータベースを共有することがない、その唯一の所有者である必要があります。 マイクロサービスのすべてのインスタンスは、当然同じ高可用性のデータベースに接続されます。
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/20/2018
ms.openlocfilehash: 136f8d173042ab235e5fa3c8478f4aa5659a9787
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/10/2018
ms.locfileid: "53126849"
---
# <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="b3d47-105">マイクロサービス単位のデータ管理</span><span class="sxs-lookup"><span data-stu-id="b3d47-105">Data sovereignty per microservice</span></span>

<span data-ttu-id="b3d47-106">マイクロサービス アーキテクチャの重要なルールは、各マイクロサービスがそのドメイン データとロジックを所有する必要があるということです。</span><span class="sxs-lookup"><span data-stu-id="b3d47-106">An important rule for microservices architecture is that each microservice must own its domain data and logic.</span></span> <span data-ttu-id="b3d47-107">完全なアプリケーションはそのロジックとデータを所有するしますが、それと同様に、各マイクロサービスは、マイクロサービスごとに独立した展開を持ち、自律的なライフサイクルでロジックとデータを所有している必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-107">Just as a full application owns its logic and data, so must each microservice own its logic and data under an autonomous lifecycle, with independent deployment per microservice.</span></span>

<span data-ttu-id="b3d47-108">つまり、サブシステムとマイクロサービスとの間で、ドメインの概念モデルが異なるものになります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-108">This means that the conceptual model of the domain will differ between subsystems or microservices.</span></span> <span data-ttu-id="b3d47-109">顧客関係管理 (CRM) アプリケーション、取引購買サブシステム、顧客サポート サブシステムから成るエンタープライズ アプリケーションがあるとします。ここで、各アプリケーションやサブシステムは、それぞれ特有の顧客エンティティ属性やデータを呼び出し、異なる境界コンテキスト (BC) を利用します。</span><span class="sxs-lookup"><span data-stu-id="b3d47-109">Consider enterprise applications, where customer relationship management (CRM) applications, transactional purchase subsystems, and customer support subsystems each call on unique customer entity attributes and data, and where each employs a different Bounded Context (BC).</span></span>

<span data-ttu-id="b3d47-110">この原則は、[ドメイン駆動型設計 (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design) でも同様です。DDD の場合、各[境界コンテキスト](https://martinfowler.com/bliki/BoundedContext.html)、自律サブシステム、自律サービスは、独自のドメイン モデル (データ + ロジックと動作) を所有する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-110">This principle is similar in [Domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), where each [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) or autonomous subsystem or service must own its domain model (data plus logic and behavior).</span></span> <span data-ttu-id="b3d47-111">各 DDD 制限コンテキストは、1 つのビジネス マイクロサービス (1 つまたは複数のサービス) と関連しています</span><span class="sxs-lookup"><span data-stu-id="b3d47-111">Each DDD Bounded Context correlates to one business microservice (one or several services).</span></span> <span data-ttu-id="b3d47-112">次のセクションでは、境界コンテキスト パターンのこの点について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="b3d47-112">This point about the Bounded Context pattern is expanded in the next section.</span></span>

<span data-ttu-id="b3d47-113">一方、多くのアプリケーションで使用されている従来の (モノリシックなデータ) アプローチは、単一の中央のデータベースまたはごく少数のデータベースを持つ方法です。</span><span class="sxs-lookup"><span data-stu-id="b3d47-113">On the other hand, the traditional (monolithic data) approach used in many applications is to have a single centralized database or just a few databases.</span></span> <span data-ttu-id="b3d47-114">図 4-7 に示すように、多くの場合、これは正規化された SQL Server です。アプリケーション全体とその内部にあるすべてのサブシステムに使用されます。</span><span class="sxs-lookup"><span data-stu-id="b3d47-114">This is often a normalized SQL database that's used for the whole application and all its internal subsystems, as shown in Figure 4-7.</span></span>

![従来のアプローチでは、すべてのサービスが、通常は 1 つの階層型アーキテクチャ内で 1 つのデータベースを共有していました。](./media/image7.png)

<span data-ttu-id="b3d47-117">**図 4-7**.</span><span class="sxs-lookup"><span data-stu-id="b3d47-117">**Figure 4-7**.</span></span> <span data-ttu-id="b3d47-118">データ管理の比較: モノリシック データベースとマイクロサービス</span><span class="sxs-lookup"><span data-stu-id="b3d47-118">Data sovereignty comparison: monolithic database versus microservices</span></span>

<span data-ttu-id="b3d47-119">中央のデータベース アプローチは、最初は単純に思え、さまざまなサブシステムでエンティティを再利用してすべての一貫性を保てるように思えます。</span><span class="sxs-lookup"><span data-stu-id="b3d47-119">The centralized database approach initially looks simpler and seems to enable reuse of entities in different subsystems to make everything consistent.</span></span> <span data-ttu-id="b3d47-120">しかし、実際は、多くの異なるサブシステムにサービスを提供する、ほとんどの場合に必要のない属性や列を含んだ大きなテーブルを用意することになります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-120">But the reality is you end up with huge tables that serve many different subsystems, and that include attributes and columns that aren't needed in most cases.</span></span> <span data-ttu-id="b3d47-121">これは、短い散歩にも、日帰りドライブにも、地理の勉強にも、同じ縮尺の地図を利用するようなものです。</span><span class="sxs-lookup"><span data-stu-id="b3d47-121">It's like trying to use the same physical map for hiking a short trail, taking a day-long car trip, and learning geography.</span></span>

<span data-ttu-id="b3d47-122">通常は単一のリレーショナル データベースを使用するモノリシック アプリケーションには、[ACID トランザクション](https://en.wikipedia.org/wiki/ACID)と SQL 言語という 2 つの重要な利点があります。このいずれも、アプリケーションに関連するすべてのテーブルとデータを処理します。</span><span class="sxs-lookup"><span data-stu-id="b3d47-122">A monolithic application with typically a single relational database has two important benefits: [ACID transactions](https://en.wikipedia.org/wiki/ACID) and the SQL language, both working across all the tables and data related to your application.</span></span> <span data-ttu-id="b3d47-123">このアプローチを利用すると、複数のテーブルのデータを結合するクエリを簡単に記述することができます。</span><span class="sxs-lookup"><span data-stu-id="b3d47-123">This approach provides a way to easily write a query that combines data from multiple tables.</span></span>

<span data-ttu-id="b3d47-124">一方、マイクロサービス アーキテクチャに移行すると、データ アクセスははるかに複雑になります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-124">However, data access becomes much more complex when you move to a microservices architecture.</span></span> <span data-ttu-id="b3d47-125">ただし、マイクロサービスまたは境界コンテキスト内で ACID トランザクションを使用できる場合、または使用する必要がある場合でも、各マイクロサービスが所有するデータは、そのマイクロサービス専用です。また、マイクロサービス API を介してのみアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="b3d47-125">But even when ACID transactions can or should be used within a microservice or Bounded Context, the data owned by each microservice is private to that microservice and can only be accessed via its microservice API.</span></span> <span data-ttu-id="b3d47-126">データをカプセル化することで、マイクロサービス間の結合は弱くなり、相互に独立して進化できます。</span><span class="sxs-lookup"><span data-stu-id="b3d47-126">Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another.</span></span> <span data-ttu-id="b3d47-127">複数のサービスが同じデータにアクセスしている場合、スキーマの更新にはすべてのサービスに対する更新を調整する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-127">If multiple services were accessing the same data, schema updates would require coordinated updates to all the services.</span></span> <span data-ttu-id="b3d47-128">これではマイクロサービスのライフサイクルの自律性が失われます。</span><span class="sxs-lookup"><span data-stu-id="b3d47-128">This would break the microservice lifecycle autonomy.</span></span> <span data-ttu-id="b3d47-129">ただし、分散データ構造なので、マイクロサービス全体で単一の ACID トランザクションは作成できません。</span><span class="sxs-lookup"><span data-stu-id="b3d47-129">But distributed data structures mean that you can't make a single ACID transaction across microservices.</span></span> <span data-ttu-id="b3d47-130">つまり、ビジネス プロセスが複数のマイクロサービスにまたがる場合、最終的な整合性を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-130">This in turn means you must use eventual consistency when a business process spans multiple microservices.</span></span> <span data-ttu-id="b3d47-131">これは、後述するとおり、別のデータベース間で整合性制約を作成したり、分散トランザクションを使用したりできないので、単純な SQL 結合を実装するよりも困難になります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-131">This is much harder to implement than simple SQL joins, because you can't create integrity constraints or use distributed transactions between separate databases, as we'll explain later on.</span></span> <span data-ttu-id="b3d47-132">同様に、その他の多くのリレーショナル データベース機能も、複数のマイクロサービス間で使用できません。</span><span class="sxs-lookup"><span data-stu-id="b3d47-132">Similarly, many other relational database features aren't available across multiple microservices.</span></span>

<span data-ttu-id="b3d47-133">さらに進んで、複数のマイクロサービスがさまざまな*種類*のデータベースを使用することもよくあります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-133">Going even further, different microservices often use different *kinds* of databases.</span></span> <span data-ttu-id="b3d47-134">最新のアプリケーションではさまざまなデータを格納して処理するので、リレーショナル データベースは常に最善の選択肢とはなりません。</span><span class="sxs-lookup"><span data-stu-id="b3d47-134">Modern applications store and process diverse kinds of data, and a relational database isn't always the best choice.</span></span> <span data-ttu-id="b3d47-135">一部のユース ケースでは、Azure CosmosDB や MongoDB などの NoSQL Server の方が、SQL Server や Azure SQL Database などの SQL Server よりもデータ モデルが便利で、パフォーマンスとスケーラビリティが高い場合があります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-135">For some use cases, a NoSQL database such as Azure CosmosDB or MongoDB might have a more convenient data model and offer better performance and scalability than a SQL database like SQL Server or Azure SQL Database.</span></span> <span data-ttu-id="b3d47-136">また、リレーショナル データベースが最善のアプローチのケースもあります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-136">In other cases, a relational database is still the best approach.</span></span> <span data-ttu-id="b3d47-137">そのため、マイクロサービスベースのアプリケーションでは、SQL と NoSQL のデータベースが混在することがよくあります。これは[多言語永続化](https://martinfowler.com/bliki/PolyglotPersistence.html)アプローチと呼ばれることもあります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-137">Therefore, microservices-based applications often use a mixture of SQL and NoSQL databases, which is sometimes called the [polyglot persistence](https://martinfowler.com/bliki/PolyglotPersistence.html) approach.</span></span>

<span data-ttu-id="b3d47-138">データ格納用のパーティション分割された多言語永続化アーキテクチャには、多くの利点があります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-138">A partitioned, polyglot-persistent architecture for data storage has many benefits.</span></span> <span data-ttu-id="b3d47-139">たとえば、疎結合されたサービス、パフォーマンス、スケーラビリティ、コスト、管理容易性などです。</span><span class="sxs-lookup"><span data-stu-id="b3d47-139">These include loosely coupled services and better performance, scalability, costs, and manageability.</span></span> <span data-ttu-id="b3d47-140">ただし、この章で後述する[ドメインモデルの境界の特定](identify-microservice-domain-model-boundaries.md)のように、分散データ管理の課題がいくつか生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-140">However, it can introduce some distributed data management challenges, as explained in "[Identifying domain-model boundaries](identify-microservice-domain-model-boundaries.md)" later in this chapter.</span></span>

## <a name="the-relationship-between-microservices-and-the-bounded-context-pattern"></a><span data-ttu-id="b3d47-141">マイクロサービスと境界コンテキスト パターンの関係</span><span class="sxs-lookup"><span data-stu-id="b3d47-141">The relationship between microservices and the Bounded Context pattern</span></span>

<span data-ttu-id="b3d47-142">マイクロサービスの概念は、[ドメイン駆動型設計 (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design) の[境界コンテキスト (BC) パターン](http://martinfowler.com/bliki/BoundedContext.html)に由来しています。</span><span class="sxs-lookup"><span data-stu-id="b3d47-142">The concept of microservice derives from the [Bounded Context (BC) pattern](http://martinfowler.com/bliki/BoundedContext.html) in [domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span></span> <span data-ttu-id="b3d47-143">DDD は、モデルを複数の BC に分割し、その境界を明示的にすることで大規模なモデルを扱っています。</span><span class="sxs-lookup"><span data-stu-id="b3d47-143">DDD deals with large models by dividing them into multiple BCs and being explicit about their boundaries.</span></span> <span data-ttu-id="b3d47-144">各 BC は独自のモデルとデータベースを持つ必要があります。同様に、各マイクロサービスはその関連データを所有しています。</span><span class="sxs-lookup"><span data-stu-id="b3d47-144">Each BC must have its own model and database; likewise, each microservice owns its related data.</span></span> <span data-ttu-id="b3d47-145">さらに各 BC には、ソフトウェア開発者とドメイン専門家の間のコミュニケーションに役立つ独自の[ユビキタス言語](http://martinfowler.com/bliki/UbiquitousLanguage.html)が存在するのが一般的です。</span><span class="sxs-lookup"><span data-stu-id="b3d47-145">In addition, each BC usually has its own [ubiquitous language](http://martinfowler.com/bliki/UbiquitousLanguage.html) to help communication between software developers and domain experts.</span></span>

<span data-ttu-id="b3d47-146">異なるドメイン エンティティが同じ ID (つまり、ストレージからエンティティを読み取るために使用される一意の ID) を共有している場合でも、ユビキタス言語で使われる用語 (主にドメイン エンティティ) は、境界コンテキストによって名前が異なる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-146">Those terms (mainly domain entities) in the ubiquitous language can have different names in different Bounded Contexts, even when different domain entities share the same identity (that is, the unique ID that's used to read the entity from storage).</span></span> <span data-ttu-id="b3d47-147">たとえば、"ユーザー プロファイル" 境界コンテキストの "ユーザー" ドメイン エンティティが、"注文" 境界コンテキストの "購入者" ドメイン エンティティと ID を共有する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-147">For instance, in a user-profile Bounded Context, the User domain entity might share identity with the Buyer domain entity in the ordering Bounded Context.</span></span>

<span data-ttu-id="b3d47-148">そのため、マイクロサービスは境界コンテキストと似ていますが、分散サービスであることも指定されています。</span><span class="sxs-lookup"><span data-stu-id="b3d47-148">A microservice is therefore like a Bounded Context, but it also specifies that it's a distributed service.</span></span> <span data-ttu-id="b3d47-149">これは境界コンテキストごとに個別のプロセスとして構築されます。また、前述のように分散プロトコル (HTTP/HTTPS、WebSockets、[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) など) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-149">It's built as a separate process for each Bounded Context, and it must use the distributed protocols noted earlier, like HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span> <span data-ttu-id="b3d47-150">ただし、境界コンテキスト パターンでは、境界コンテキストが分散サービスか、モノリシック展開アプリケーション内の単なる論理的な境界 (汎用サブシステムなど) かは指定されません。</span><span class="sxs-lookup"><span data-stu-id="b3d47-150">The Bounded Context pattern, however, doesn't specify whether the Bounded Context is a distributed service or if it's simply a logical boundary (such as a generic subsystem) within a monolithic-deployment application.</span></span>

<span data-ttu-id="b3d47-151">各境界コンテキストに対してサービスを定義することを出発点にすることを強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="b3d47-151">It's important to highlight that defining a service for each Bounded Context is a good place to start.</span></span> <span data-ttu-id="b3d47-152">ただし、設計で無理にそうする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b3d47-152">But you don't have to constrain your design to it.</span></span> <span data-ttu-id="b3d47-153">場合によっては、いくつかの物理サービスで構成された境界コンテキストまたはビジネス マイクロサービスを設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-153">Sometimes you must design a Bounded Context or business microservice composed of several physical services.</span></span> <span data-ttu-id="b3d47-154">ただし最終的には、境界コンテキストとマイクロサービスの両方のパターンが密接に関連することになります。</span><span class="sxs-lookup"><span data-stu-id="b3d47-154">But ultimately, both patterns -Bounded Context and microservice- are closely related.</span></span>

<span data-ttu-id="b3d47-155">DDD は、分散型マイクロサービスの形で実際の境界を獲得することで、マイクロサービスの利点を活用しています。</span><span class="sxs-lookup"><span data-stu-id="b3d47-155">DDD benefits from microservices by getting real boundaries in the form of distributed microservices.</span></span> <span data-ttu-id="b3d47-156">ただし、マイクロサービス間でモデルを共有しないようなアイデアの場合は、境界コンテキストでも実現できます。</span><span class="sxs-lookup"><span data-stu-id="b3d47-156">But ideas like not sharing the model between microservices are what you also want in a Bounded Context.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="b3d47-157">その他の技術情報</span><span class="sxs-lookup"><span data-stu-id="b3d47-157">Additional resources</span></span>

- <span data-ttu-id="b3d47-158">**Chris Richardson。パターン: サービスごとのデータベース** \\</span><span class="sxs-lookup"><span data-stu-id="b3d47-158">**Chris Richardson. Pattern: Database per service** \\</span></span>
  [*https://microservices.io/patterns/data/database-per-service.html*](https://microservices.io/patterns/data/database-per-service.html)

- <span data-ttu-id="b3d47-159">**Martin Fowler。BoundedContext** \\</span><span class="sxs-lookup"><span data-stu-id="b3d47-159">**Martin Fowler. BoundedContext** \\</span></span>
  [*https://martinfowler.com/bliki/BoundedContext.html*](https://martinfowler.com/bliki/BoundedContext.html)

- <span data-ttu-id="b3d47-160">**Martin Fowler。PolyglotPersistence** \\</span><span class="sxs-lookup"><span data-stu-id="b3d47-160">**Martin Fowler. PolyglotPersistence** \\</span></span>
  [*https://martinfowler.com/bliki/PolyglotPersistence.html*](https://martinfowler.com/bliki/PolyglotPersistence.html)

- <span data-ttu-id="b3d47-161">**Alberto Brandolini。コンテキスト マッピングを使用した戦略的ドメイン駆動設計** \\</span><span class="sxs-lookup"><span data-stu-id="b3d47-161">**Alberto Brandolini. Strategic Domain Driven Design with Context Mapping** \\</span></span>
  [*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)

>[!div class="step-by-step"]
><span data-ttu-id="b3d47-162">[前へ](microservices-architecture.md)
>[次へ](logical-versus-physical-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="b3d47-162">[Previous](microservices-architecture.md)
[Next](logical-versus-physical-architecture.md)</span></span>