---
title: 破壊的変更と .NET ライブラリ
description: .NET ライブラリを作成するとき、破壊的変更を進行させるためのベストプラクティス推奨事項。
author: jamesnk
ms.author: mairaw
ms.date: 10/02/2018
ms.openlocfilehash: e0e62cda1b7475cd5d1f8bcd3558dc2fe7f6e07c
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/10/2018
ms.locfileid: "53148511"
---
# <a name="breaking-changes"></a>互換性に影響する変更

.NET ライブラリでは既存のユーザーに向けた安定性と将来に向けたイノベーションとの間でバランスを取ることが重要です。 ライブラリ作成者にはコードが完璧になるまでコードを再構成し、再考する傾向がありますが、既存のユーザーを壊すと、特に低レベルのライブラリに対して、マイナスの影響が出ます。

## <a name="project-types-and-breaking-changes"></a>プロジェクトの種類と破壊的変更

.NET コミュニティによるライブラリの使用方法によって、破壊的変更がエンドユーザー開発者に与える影響が変わります。

* シリアライザー、HTML パーサー、データベース オブジェクトリレーショナル マッパー、Web フレームワークなど、**低レベル/中レベルのライブラリ**が破壊的変更の影響を最も大きく受けます。

  ビルディング ブロック パッケージは、アプリケーションを構築する目的でエンドユーザー開発者が使用します。また、NuGet 依存関係として他のライブラリによって使用されます。 たとえば、アプリケーションを構築しているとき、オープン ソースのクライアントを使用して Web サービスを呼び出すとします。 クライアントで使用される依存関係に対する破壊的更新は自分で修正できるものではありません。 変更しなければならないのはオープンソースのクライアントであり、それに対しては何の権限もありません。 互換性のあるライブラリ バージョンを探すか、クライアント ライブラリの修正案を提出し、新しいバージョンが出るのを待つ必要があります。 最悪なケースは、使用する 2 つのライブラリが依存する 3 つ目のライブラリのバージョン間で互換性がない場合です。

* UI コントロール スイートなど、**高レベルのライブラリ**の場合、破壊的変更の影響が小さくなります。

  エンドユーザー アプリケーションでは、高レベルのライブラリは直接参照されます。 破壊的変更が行われた場合、開発者は最新版への更新を選択するか、破壊的変更に合わせてアプリケーションを変更できます。

**✔️ 実行すること**: ライブラリの使われ方について良く考える。 破壊的変更はそれを使用するアプリケーションやライブラリにどのような影響を及ぼしますか。

**✔️ 実行すること**: 低レベルの .NET ライブラリを開発するときは、破壊的変更を最小限に抑える。

**✔️ 検討すること**: ライブラリを大幅に書き直した場合、新しい NuGet パッケージとして公開する。

## <a name="types-of-breaking-changes"></a>破壊的変更の種類

破壊的変更はさまざまなカテゴリに属し、その影響力は一様ではありません。

### <a name="source-breaking-change"></a>ソースの破壊的変更

ソースの破壊的変更はプログラム実行に影響を与えませんが、次回、アプリケーションを再コンパイルしたとき、コンパイル エラーを引き起こします。 たとえば、新しいオーバーロードによって、以前はあいまいではなかったメソッド呼び出しに多義性が与えられることがあります。あるいは、パラメーターの名前が変更されると、名前付きパラメーターを使用する呼び出し元が壊れます。

```csharp
public class Task
{
    // Adding a type called Task could conflict with System.Threading.Tasks.Task at compilation
}
```

ソースの破壊的変更は開発者がアプリケーションを再コンパイルするときにのみ害があります。そのため、破壊的変更の中では破壊性が最も少なくなります。 開発者は壊れた自分のソース コードを簡単に修正できます。

### <a name="behavior-breaking-change"></a>動作の破壊的変更

動作変更は破壊的変更の中で最も一般的な種類です。動作の場合、何を変更してもたいていは誰かにとって破壊性があります。 メソッド シグネチャ、スローされた例外、入力/出力データ形式など、ライブラリの変更はすべて、ライブラリの利用者にマイナスの影響の与える可能性があります。 以前の壊れていた動作にユーザーが依存していた場合、バグの修正が破壊的変更になることがあります。

機能の追加や不適切動作の改善は良いことですが、慎重に行わない場合、既存ユーザーにとってアップグレードが非常に難しくなります。 動作の破壊的変更の前に "設定" を置くことが、変更に対処する開発者を助ける 1 つの方法です。 この "設定" で開発者はライブラリの最新版に更新し、同時に破壊的変更の採用を選択できます。 このような方法をとることで、開発者は最新の状態を維持しながら、時間をかけてコードを調整できます。

たとえば、ASP.NET Core MVC には、`MvcOptions` で有効/無効になっている機能を変更する[互換性バージョン](/aspnet/core/mvc/compatibility-version)という概念があります。

**✔️ 検討すること**: 既存ユーザーに影響を与えるなら、新しい機能は既定でオフにし、開発者に設定で選択させる。

### <a name="binary-breaking-change"></a>バイナリの破壊的変更

バイナリの破壊的変更は、ライブラリのパブリック API を変更するときに発生します。そのため、旧バージョンのライブラリに対してコンパイルされたアセンブリはその API を呼び出せなくなります。 たとえば、新しいパラメーターを追加してメソッドのシグネチャを変更すると、旧バージョンのライブラリに対してコンパイルされたアセンブリから <xref:System.MissingMethodException> がスローされます。

バイナリの破壊的変更は**アセンブリ全体**を壊すこともあります。 `AssemblyName` でアセンブリの名前を変更すると、アセンブリの ID が変更されます。アセンブリの厳密な名前付けキーを追加、削除、変更した場合も同様に ID が変更されます。 アセンブリの ID を変更すると、それを使用するすべてのコンパイル済みコードが壊れます。

**❌ してはいけないこと**: アセンブリ名を変更する。

**❌ してはいけないこと**: 厳密な名前付けキーを追加、削除、変更する。

**✔️ 検討すること**: インターフェイスではなく、抽象基本クラスを使用する。

> インターフェイスに何かを追加すると、そのインターフェイスを実装する既定の型でエラーが出ます。 抽象基本クラスを使用すると、既定の仮想実装を追加できます。

**✔️ 検討すること**: 削除する予定の型とメンバーに <xref:System.ObsoleteAttribute> を置く。 この属性によって、無効になった API を使用しないようにコードを更新するための指示が与えられます。

> <xref:System.ObsoleteAttribute> が与えられた型やメソッドをコードが呼び出すと、ビルドの警告が出され、属性にメッセージが与えられます。 この警告によって、無効になった API を使用している人に十分な移行時間が与えられます。無効になった API が削除されたとき、ほとんどの人がそれを使用しなくなっています。

```csharp
public class Document
{
    [Obsolete("LoadDocument(string) is obsolete. Use LoadDocument(Uri) instead.")]
    public static Document LoadDocument(string uri)
    {
        return LoadDocument(new Uri(uri));
    }

    public static Document LoadDocument(Uri uri)
    {
        // Load the document
    }
}
```

**✔️ 検討すること**: 低レベル/中レベルのライブラリの場合、<xref:System.ObsoleteAttribute> が与えられた型やメソッドを無期限で保持する。

> API を削除することはバイナリの破壊的変更です。 保守管理コストが低く、ライブラリに与える技術的な負荷が大きくなければ、無効になった型とメソッドを保持することを検討してください。 型やメソッドを削除しなければ、前述の最悪なケースを回避できる可能性があります。

## <a name="see-also"></a>関連項目

* [C# 開発者向けのバージョンと更新に関する考慮事項](../../csharp/whats-new/version-update-considerations.md)
* [API の決定版ガイド - .NET の破壊的変更](https://stackoverflow.com/questions/1456785/a-definitive-guide-to-api-breaking-changes-in-net)
* [CoreFX 破壊的変更ルール](https://github.com/dotnet/corefx/blob/master/Documentation/coding-guidelines/breaking-change-rules.md)

>[!div class="step-by-step"]
>[前へ](versioning.md)