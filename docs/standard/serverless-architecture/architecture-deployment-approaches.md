---
title: アーキテクチャのデプロイ方法 - サーバーレス アプリ
description: エンタープライズ アーキテクチャのさまざまな方法のガイドは、IaaS、PaaS、コンテナー間の比較で、クラウドにデプロイおよびサーバーレスです。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: 6566971d8984ec046b8b5fa2db295c1d48c30b20
ms.sourcegitcommit: 4c158beee818c408d45a9609bfc06f209a523e22
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/03/2018
ms.locfileid: "49370211"
---
# <a name="architecture-deployment-approaches"></a>アーキテクチャのデプロイ方法

アーキテクチャに関係なく、ビジネス アプリケーションでは、実装、またはそれらのアプリケーションの展開を設計するために使用する方法が異なる場合があります。 企業では、サーバーレス関数をすべての物理ハードウェアでアプリケーションをホストします。

## <a name="n-tier-applications"></a>n 層アプリケーション

[N 層アーキテクチャ パターン](https://docs.microsoft.com/azure/architecture/guide/architecture-styles/n-tier)完成度の高いアーキテクチャは、単純にさまざまな論理層を別々 の物理層に分離するアプリケーションを参照します。 N 層アーキテクチャは、N 層アーキテクチャの物理的な実装です。 このアーキテクチャの最も一般的な実装は次のとおりです。

* プレゼンテーション層では、web アプリなどです。
* API やデータを REST API などのレベルにアクセスします。
* SQL database などのデータ層。

![N 層アーキテクチャ](./media/n-tier-architecture.png)

N 層ソリューションには、次の特性があります。

* プロジェクトは通常、層で配置します。
* テスト アプローチできる異なるレベルでします。
* たとえば、プレゼンテーション層は、データ層の実装の詳細を意識する通常、階層がの抽象化レイヤーを提供します。
* 通常、レイヤーは、隣接するレイヤーとのみ対話します。
* リリースでは、プロジェクトで多くの場合、管理され、そのための階層、レベル。 API の簡単な変更には、全体の中間層の新しいリリースが必要です。

このアプローチなど、いくつかの利点があります。

* データベースの独立性 (多くの場合、フロント エンドはバックエンド データベースに直接アクセスするとありません)。
* (たとえば、モバイル、デスクトップ、および web アプリのクライアントがすべて同じ Api を再利用することができます)、API の再利用します。
* スケール アウト層が互いに独立して機能します。
* 分離のリファクタリング: 他の層に影響を与えることがなく 1 つの層をリファクタリングすることがあります。

## <a name="on-premises-and-infrastructure-as-a-service-iaas"></a>オンプレミスと Infrastructure as a Service (IaaS)

アプリケーションをホストするには、従来のアプローチでは、ハードウェアを購入し、すべてのオペレーティング システムを含む、ソフトウェアのインストールを管理する必要があります。 最初は高額なデータ センターと物理ハードウェアに関係します。 物理ハードウェアの動作に付属している課題が多くなど。

* 「の場合のみ」の余分な購入またはピーク時の需要シナリオに必要です。
* ハードウェアに物理的にアクセスをセキュリティで保護します。
* ハードウェア障害 (ディスクの障害) などを担当します。
* 冷却装置。
* ルーター、ロード バランサーを構成します。
* 電源の冗長性。
* ソフトウェアへのアクセスをセキュリティで保護します。

![IaaS アプローチ](./media/iaas-approach.png)

「仮想マシン」を使用して、ハードウェア仮想化は、a Service (IaaS) としてのインフラストラクチャを有効にします。 ホスト コンピューターは、インスタンスにリソースを割り当て、独自のメモリ、CPU、および記憶域を提供する効果的なパーティション分割されます。 チームは、必要な Vm をプロビジョニングし、関連付けられているネットワークと記憶域へのアクセスを構成します。

詳細については、次を参照してください。[参照アーキテクチャを N 層の仮想マシン](https://docs.microsoft.com/azure/architecture/reference-architectures/virtual-machines-windows/n-tier)します。

仮想化と Infrastructure as a Service (IaaS) 多くの懸念に対処がまだインフラストラクチャ チームの手に多くの責任が残ります。 チームは、セキュリティ修正プログラムを適用、および対象のコンピューターでサード パーティの依存関係をインストールするオペレーティング システム バージョン管理を行います。 アプリは多くの場合、テスト環境と比較して、実稼動コンピューターで異なる方法で動作します。 問題は、さまざまな依存関係のバージョンや OS SKU レベルが原因で発生します。 多くの企業がメリットなど、複数のクラウド ネイティブ モデルへのデプロイが、多くの組織では、これらのターゲットに N 層アプリケーションをデプロイ、[サービスとしてのプラットフォーム](#platform-as-a-service-paas)します。 マイクロ サービス アーキテクチャは、弾力性と回復性のスケール アウトするための要件のためより困難になります。

詳細については、次を参照してください。[仮想マシン](https://docs.microsoft.com/azure/virtual-machines/)します。

## <a name="platform-as-a-service-paas"></a>Platform as a Service (PaaS)

プラットフォーム (PaaS) サービスが提供には開発者が直接接続できるソリューションを構成します。 PaaS は、管理対象のホスティングを別の用語です。 基本のオペレーティング システムを管理する必要がある、セキュリティ更新プログラムまたは多くの場合、サード パーティの依存関係。 プラットフォームのものが web アプリケーション、データベース、およびモバイル バックエンド。

PaaS は、IaaS に共通の課題に対処します。 PaaS では、開発者がデプロイされる方法ではなく、コードまたはデータベース スキーマに集中できるようにします。 PaaS の利点は次のとおりです。

* アイドル状態のマシンへの投資のオーバーヘッドが生じないようにモデルを使用に対して課金されます。
* 展開と強化された DevOps、継続的インテグレーション (CI)、および継続的デリバリー (CD) パイプラインに指示します。
* 自動アップグレード、更新、およびセキュリティ更新プログラム。
* クリック 1 回のスケール アウトとスケール アップ (エラスティック スケール)。

従来、PaaS の主な欠点はベンダーにでしたが。 たとえば、PaaS プロバイダーによっては、ASP.NET、Node.js、またはその他の特定の言語およびプラットフォームをサポートのみです。 Azure App Service などの製品は、複数のプラットフォームに対応し、web アプリをホストするためのさまざまな言語とフレームワークのサポートに進化してきました。

![サービスのアーキテクチャとしてのプラットフォーム](./media/paas-architecture.png)

## <a name="software-as-a-service-saas"></a>Software as a Service (SaaS)

サービスまたは SaaS としてのソフトウェアは、一元的にホストされているし、ローカルにインストールしていない場合またはプロビジョニングができます。 SaaS 多くの場合がホストされている PaaS 上にソフトウェアを展開するためのプラットフォームとして。 SaaS では、サービスを実行し、既存のソフトウェアとの接続を提供します。 SaaS は、業界および特定の垂直方向でがよくあります。 SaaS では、ライセンスは多くの場合と、通常、クライアント/サーバー モデルを提供します。 ほとんどの最新の SaaS サービスでは、クライアントの web ベースのアプリを使用します。 通常、企業は、ライセンス ソリューションをビジネス ソリューションとして SaaS を検討します。 多くの場合、スケーラビリティとアプリケーションの保守容易性のためのアーキテクチャの考慮事項として実装されていません。 実際、ほとんどの SaaS ソリューションは、IaaS、PaaS、およびバック エンドのサーバーレスに基づいて構築されます。

詳細から SaaS については、[サンプル アプリケーション](https://docs.microsoft.com/azure/sql-database/saas-tenancy-welcome-wingtip-tickets-app)します。

## <a name="containers-and-functions-as-a-service-faas"></a>コンテナーとサービス (FaaS) としての関数

コンテナーは、IaaS のオーバーヘッドなしに PaaS のような利点をできるようにする興味深いソリューションです。 コンテナーとは、本質的に一意のアプリケーションの実行に必要な最低限を含むランタイムです。 ホスト オペレーティング システムと記憶域などのサービスのカーネルまたは core の一部は、ホスト間で共有されます。 共有カーネルが軽量になるコンテナーを使用する (一部は単なるメガバイト、ギガバイト典型的な仮想マシンのサイズと比較して、サイズです)。 既に実行中のホストを持つコンテナーを開始できます簡単に、高可用性をサポートすること。 コンテナーをすばやくスピンアップする機能には、回復性の余分なレイヤーも提供します。 Docker では、コンテナーの最も一般的な実装の 1 つです。

コンテナーの利点は次のとおりです。

* 軽量かつポータブル
* 自己完結型の依存関係をインストールする必要はありません
* ホストの (ラップトップ コンピューターで正確に同じクラウド サーバーで実行される) に関係なく一貫した環境を提供します。
* スケール アウトを迅速にプロビジョニングできます。
* 障害から復旧する迅速に再開できます。

コンテナーは、(さらには、ベア メタル マシンまたは仮想マシンで実行される可能性が) をコンテナー ホストで実行されます。 複数のコンテナーまたは同じコンテナーのインスタンスを 1 つのホストで実行できます。 True のフェールオーバーと回復性は、コンテナーのホスト間でスケールする必要があります。

Docker コンテナーの詳細については、次を参照してください。 [docker](../microservices-architecture/container-docker-introduction/docker-defined.md)でしょうか。

通常のホスト間でコンテナーを管理するには、Kubernetes など、オーケストレーション ツールが必要です。 構成して、オーケストレーション ソリューションの管理可能性があります追加オーバーヘッドや複雑さをプロジェクトに追加します。 さいわい、多くのクラウド プロバイダーは、コンテナーの管理を簡略化の PaaS ソリューションからオーケストレーション サービスを提供します。

次の図は、Kubernetes のインストール例を示します。 ノードのインストールでは、スケール アウトやフェールオーバーに対応できます。 これらは、Docker に、マスター サーバーによって管理されているコンテナー インスタンスを実行します。 *Kubelet* Kubernetes から Docker にコマンドを中継するクライアントです。

![Kubernetes](./media/kubernetes-example.png)

オーケストレーションの詳細については、次を参照してください。 [Kubernetes on Azure](https://docs.microsoft.com/azure/aks/intro-kubernetes)します。

(FaaS) サービスとしての関数は、サーバーレスのような特殊化されたコンテナー サービスです。 特定の実装と呼ばれる FaaS の[OpenFaaS](https://github.com/openfaas/faas)、サーバーレス機能を提供するコンテナーの上に位置します。 OpenFaaS には、すべてのコードを実行するために必要なコンテナーの依存関係のパッケージ テンプレートが用意されています。 テンプレートを使用して、機能の単位としてコードをデプロイするプロセスが簡略化します。 OpenFaaS には、既存のインフラストラクチャを使用できるため、既にコンテナーおよびオーケストレーターを含むアーキテクチャが対象とします。 サーバーレス機能を提供しますが、具体的には必要がある Docker とオーケストレーターを使用します。

## <a name="serverless"></a>サーバーレス

サーバーレス アーキテクチャでは、明確に分離コードとそのホスティング環境を提供します。 内のコードを実装する、*関数*によって呼び出される、*トリガー*します。 その関数が終了した後、そのすべての必要なリソースが解放があります。 トリガーには、手動、時間指定のプロセス、HTTP 要求、またはファイルのアップロードがあります。 トリガーの結果は、コードの実行です。 サーバーレス プラットフォーム異なりますが、最もデータベースまたはキューの結果への書き込みなどのタスクを合理化する、定義済みの Api とバインドにアクセスを提供します。

サーバーレスは、コードに集中するホスト環境を取り除くことに大きく依存しているアーキテクチャです。 として考えることできます*少ないサーバー*します。

コンテナー ソリューションは、開発者が既存のビルドにイメージの準備完了でサーバーレス コードを発行するスクリプトを提供します。 他の実装では、既存の PaaS ソリューションを使用して、スケーラブルなアーキテクチャを提供します。

抽象化では、DevOps チーム プロビジョニングまたはサーバー、または特定のコンテナーを管理する必要はありませんを意味します。 サーバーレス プラットフォーム ホスト コード、スクリプトまたはパッケージの実行可能ファイルとしては、関連の SDK でビルドし、スケールするためのコードで必要なリソースを割り当てます。

次の図は、4 つのサーバーレス コンポーネントをダイアグラムします。 HTTP 要求は、チェック アウト API コードを実行するとします。 Checkout API がデータベースにコードを挿入し、挿入は、コンピューティング タスクと、注文などのタスクを実行し、その他のいくつかの関数をトリガーします。

![サーバーレスの実装](./media/serverless-implementation.png)

サーバーレスの利点があります。

* **高密度です。** 同じサーバーレス コードの多くの場合は、コンテナーまたは仮想マシンと比較して同じホストで実行できます。 複数のホストのスケール アウトと回復性のインスタンスのスケール。
* **マイクロ-請求**します。 特定のシナリオで膨大なコスト削減を有効にする、サーバーレス実行に基づく最もサーバーレスのプロバイダー請求します。
* **瞬時に拡張**します。 サーバーレスは、ワークロードに合わせて自動的かつ迅速にスケールできます。
* **市場投入時間を短縮**開発者がコードに集中し、サーバーレスのプラットフォームに直接展開します。 コンポーネントは、それぞれ個別にリリースできます。

サーバーレス コンピューティングのコンテキストで最も多くの場合については説明が、データにも適用できます。 たとえば、 [Azure SQL](https://docs.microsoft.com/azure/sql-database)と[Cosmos DB](https://docs.microsoft.com/azure/cosmos-db)のホスト コンピューターまたはクラスターを構成することを必要としないクラウド データベースを提供します。 この本は、サーバーレス コンピューティングについて説明します。

## <a name="summary"></a>まとめ

さまざまなハイブリッド アプローチを含めて、アーキテクチャで使用できる選択肢があります。 サーバーレスには、方法、管理、およびコントロールと移植性を犠牲アプリケーション機能のコストが簡略化します。 ただし、多くのサーバーレス プラットフォームでは、ソリューションを微調整する構成を公開しないでください。 優れたプログラミング プラクティスはより移植可能なコード、およびサーバーレス プラットフォーム ロックであまりにもつながります。 次の表は、サイド バイ サイドのアーキテクチャ アプローチを示しています。 サーバーレスに基づいて、スケールのニーズが、ランタイムを管理するかどうか、および小規模コンポーネントに、ワークロードを分割する方法も選択します。 サーバーレスで潜在的な課題と次の章では、その他の意思決定ポイントについて説明します。

|         |IaaS     |PaaS     |コンテナー|サーバーレス|
|---------|---------|---------|---------|----------|
|**拡大縮小**|VM       |[インスタンス] |アプリ      |関数  |
|**抽象化します。**|ハードウェア|プラットフォーム|OS のホスト|ランタイム   |
|**ユニット** |VM       |プロジェクト  |イメージ    |コード      |
|**有効期間**|か月間|数か月の日数|日分|分 (ミリ秒)|
|**責任**|アプリケーション、依存関係、ランタイム、およびオペレーティング システム|アプリケーションと依存関係|アプリケーション、依存関係、およびランタイム|関数

* **スケール**アプリケーションをスケーリングするために使用される単位を指す
* **抽象化**は実装で抽象化レイヤーには
* **単位**展開されているスコープを参照
* **有効期間**特定のインスタンスの一般的なランタイムを参照
* **責任**構築、デプロイ、およびアプリケーションを維持するオーバーヘッドを参照

[次へ] の章はサーバーレス アーキテクチャに集中、ユース ケース、および、設計パターン。

## <a name="recommended-resources"></a>推奨リソース

* [Azure アプリケーション アーキテクチャ ガイド](https://docs.microsoft.com/azure/architecture/guide/)
* [Azure Cosmos DB](https://docs.microsoft.com/azure/cosmos-db)
* [Azure SQL](https://docs.microsoft.com/azure/sql-database)
* [N 層アーキテクチャのパターン](https://docs.microsoft.com/azure/architecture/guide/architecture-styles/n-tier)
* [Kubernetes on Azure](https://docs.microsoft.com/azure/aks/intro-kubernetes)
* [マイクロ サービス](https://docs.microsoft.com/azure/architecture/guide/architecture-styles/microservices)
* [仮想マシンの N 層の参照アーキテクチャ](https://docs.microsoft.com/azure/architecture/reference-architectures/virtual-machines-windows/n-tier)
* [仮想マシン](https://docs.microsoft.com/azure/virtual-machines/)
* [Docker について](../microservices-architecture/container-docker-introduction/docker-defined.md)
* [Wingtip Tickets SaaS アプリケーション](https://docs.microsoft.com/azure/sql-database/saas-tenancy-welcome-wingtip-tickets-app)

>[!div class="step-by-step"]
[前へ](architecture-approaches.md)
[次へ](serverless-architecture.md)