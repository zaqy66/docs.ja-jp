---
title: モノリシック アプリケーション
description: モノリシック アプリケーションをコンテナー化の主要な概念を理解します。
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 02/15/2019
ms.openlocfilehash: eff764472b4a9fc5b699545fc9629cc12d0186ca
ms.sourcegitcommit: 8f95d3a37e591963ebbb9af6e90686fd5f3b8707
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/23/2019
ms.locfileid: "56747263"
---
# <a name="monolithic-applications"></a><span data-ttu-id="ab905-103">モノリシック アプリケーション</span><span class="sxs-lookup"><span data-stu-id="ab905-103">Monolithic applications</span></span>

<span data-ttu-id="ab905-104">このシナリオでは、1 つのモノリシックな web アプリケーションまたはサービスを構築、コンテナーとして展開します。</span><span class="sxs-lookup"><span data-stu-id="ab905-104">In this scenario, you are building a single and monolithic web application or service and deploying it as a container.</span></span> <span data-ttu-id="ab905-105">アプリケーション内で、構造体できない可能性がありますモノリシック;いくつかのライブラリ、コンポーネント、またはさらにはレイヤー (アプリケーション層、ドメイン層、データ アクセス層など) を構成する場合があります。</span><span class="sxs-lookup"><span data-stu-id="ab905-105">Within the application, the structure might not be monolithic; it might comprise several libraries, components, or even layers (application layer, domain layer, data access layer, etc.).</span></span> <span data-ttu-id="ab905-106">外部で 1 つのプロセス、単一の web アプリケーション、または 1 つのサービスのように、1 つのコンテナーになります。</span><span class="sxs-lookup"><span data-stu-id="ab905-106">Externally, it is a single container, like a single process, single web application, or single service.</span></span>

<span data-ttu-id="ab905-107">このモデルを管理するには、アプリケーションを表す単一のコンテナーを展開します。</span><span class="sxs-lookup"><span data-stu-id="ab905-107">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="ab905-108">これを拡大するには、ロード バランサーを前面に配置してコピーをいくつか追加します。</span><span class="sxs-lookup"><span data-stu-id="ab905-108">To scale it, just add a few more copies with a load balancer in front.</span></span> <span data-ttu-id="ab905-109">わかりやすくするため、1 つのコンテナーまたは仮想マシン (VM) で 1 つの展開の管理に由来します。</span><span class="sxs-lookup"><span data-stu-id="ab905-109">The simplicity comes from managing a single deployment in a single container or virtual machine (VM).</span></span>

<span data-ttu-id="ab905-110">次のコンテナーがのみ、この操作を 1 つと、1 つのプロセスでは、プリンシパル、モノリシック パターンが競合します。</span><span class="sxs-lookup"><span data-stu-id="ab905-110">Following the principal that a container does one thing only, and does it in one process, the monolithic pattern is in conflict.</span></span> <span data-ttu-id="ab905-111">図 4-1 に示すように、複数のコンポーネント/ライブラリ、または内部レイヤーを各コンテナーを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="ab905-111">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 4-1.</span></span>

![モノリシック アプリが、ほとんどすべての単一のプロセスまたはコンテナー内でその機能と内部レイヤーやライブラリで、コンポーネント化されました。](./media/image1.png)

<span data-ttu-id="ab905-113">**図 4-1**</span><span class="sxs-lookup"><span data-stu-id="ab905-113">**Figure 4-1.**</span></span> <span data-ttu-id="ab905-114">モノリシック アプリケーションのアーキテクチャの例</span><span class="sxs-lookup"><span data-stu-id="ab905-114">An example of monolithic application architecture</span></span>

<span data-ttu-id="ab905-115">このアプローチの欠点は、またはアプリケーションを拡張、スケーリングする必要な場合は取得されます。</span><span class="sxs-lookup"><span data-stu-id="ab905-115">The downside to this approach comes if or when the application grows, requiring it to scale.</span></span> <span data-ttu-id="ab905-116">アプリケーション全体がスケーリングすれば、実際には問題ではありません。</span><span class="sxs-lookup"><span data-stu-id="ab905-116">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="ab905-117">ただし、ほとんどの場合、アプリケーションのいくつかの部分はチョーク ポイントをスケーリングするには、必要とするその他のコンポーネントを使用する小さい。</span><span class="sxs-lookup"><span data-stu-id="ab905-117">However, in most cases, a few parts of the application are the choke points that require scaling, whereas other components are used less.</span></span>

<span data-ttu-id="ab905-118">一般的な e コマースの例を使用して、可能性の高いが必要な製品情報のコンポーネントをスケーリングします。</span><span class="sxs-lookup"><span data-stu-id="ab905-118">Using the typical e-commerce example, what you likely need is to scale the product information component.</span></span> <span data-ttu-id="ab905-119">製品を購入するユーザーよりも多くのユーザーが製品を参照します。</span><span class="sxs-lookup"><span data-stu-id="ab905-119">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="ab905-120">より多くの顧客が、支払いパイプラインではなくバスケットを使用します。</span><span class="sxs-lookup"><span data-stu-id="ab905-120">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="ab905-121">コメントを追加したり、購入履歴を表示したりする顧客はそれほどいません。</span><span class="sxs-lookup"><span data-stu-id="ab905-121">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="ab905-122">ごく少数のコンテンツとマーケティング キャンペーンを管理する必要がある 1 つのリージョン内の従業員がある可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ab905-122">And you likely have only a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="ab905-123">モノリシックな設計をスケールすることによって複数回のコードをすべて配置されます。</span><span class="sxs-lookup"><span data-stu-id="ab905-123">By scaling the monolithic design, all of the code is deployed multiple times.</span></span>

<span data-ttu-id="ab905-124">ほかに、"スケール-すべての"アプリケーション全体とすべてのインスタンスの完全に再展開を完全に再テストの問題、1 つのコンポーネントへの変更を必要とします。</span><span class="sxs-lookup"><span data-stu-id="ab905-124">In addition to the "scale-everything" problem, changes to a single component require complete retesting of the entire application as well as a complete redeployment of all the instances.</span></span>

<span data-ttu-id="ab905-125">モノリシック アプローチは一般的であり、多くの組織はこのアーキテクチャのメソッドを使用して開発します。</span><span class="sxs-lookup"><span data-stu-id="ab905-125">The monolithic approach is common, and many organizations are developing with this architectural method.</span></span> <span data-ttu-id="ab905-126">多くは利用制限が発生する他のユーザーが、十分な結果では良いです。</span><span class="sxs-lookup"><span data-stu-id="ab905-126">Many enjoy good enough results, whereas others encounter limits.</span></span> <span data-ttu-id="ab905-127">ツールとインフラストラクチャが複雑すぎて、Soa を構築し、必要性が表示していないために、このモデルでアプリケーションを設計多く — まで、アプリが成長しました。</span><span class="sxs-lookup"><span data-stu-id="ab905-127">Many designed their applications in this model because the tools and infrastructure were too difficult to build SOAs, and they didn't see the need—until the app grew.</span></span>

<span data-ttu-id="ab905-128">インフラストラクチャの観点からは、各サーバーは、同じホスト内で多くのアプリケーションを実行し、図 4-2 に示すように、リソース使用量に効率の許容の比率があります。</span><span class="sxs-lookup"><span data-stu-id="ab905-128">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in your resources usage, as shown in Figure 4-2.</span></span>

![1 つのホストは、個別のコンテナーで複数のアプリを実行できます。](./media/image2.png)

<span data-ttu-id="ab905-130">**図 4-2**</span><span class="sxs-lookup"><span data-stu-id="ab905-130">**Figure 4-2.**</span></span> <span data-ttu-id="ab905-131">複数のアプリ/コンテナーを実行しているホスト</span><span class="sxs-lookup"><span data-stu-id="ab905-131">A host running multiple apps/containers</span></span>

<span data-ttu-id="ab905-132">最後に、可用性の観点からモノリシック アプリケーション展開する必要が; 全体つまり、必要な場合に*を停止および開始*、すべての機能とすべてのユーザーに展開時間枠中に影響は。</span><span class="sxs-lookup"><span data-stu-id="ab905-132">Finally, from an availability perspective, monolithic applications must be deployed as a whole; that means that in case you must *stop and start*, all functionality and all users will be affected during the deployment window.</span></span> <span data-ttu-id="ab905-133">特定の状況では、Azure とコンテナーの使用はこのような状況を最小限に抑えるし、図 4-3 をご覧のように、アプリケーションのダウンタイムの可能性を軽減します。</span><span class="sxs-lookup"><span data-stu-id="ab905-133">In certain situations, the use of Azure and containers can minimize these situations and reduce the probability of downtime of your application, as you can see in Figure 4-3.</span></span>

<span data-ttu-id="ab905-134">インスタンスごとに専用の Vm を使用して、Azure のモノリシック アプリケーションをデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="ab905-134">You can deploy monolithic applications in Azure by using dedicated VMs for each instance.</span></span> <span data-ttu-id="ab905-135">使用して[Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)Vm を簡単にスケールすることができます。</span><span class="sxs-lookup"><span data-stu-id="ab905-135">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can scale the VMs easily.</span></span>

<span data-ttu-id="ab905-136">使用することも[Azure App Services](https://azure.microsoft.com/services/app-service/)モノリシック アプリケーションを実行し、Vm を管理しなくてもインスタンスを簡単にスケールします。</span><span class="sxs-lookup"><span data-stu-id="ab905-136">You can also use [Azure App Services](https://azure.microsoft.com/services/app-service/) to run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="ab905-137">Azure App Services は、展開を簡素化も、Docker コンテナーの単一インスタンスを実行できます。</span><span class="sxs-lookup"><span data-stu-id="ab905-137">Azure App Services can run single instances of Docker containers, as well, simplifying the deployment.</span></span>

<span data-ttu-id="ab905-138">Docker ホストとして複数の Vm をデプロイして、任意の数の VM あたりのコンテナーを実行できます。</span><span class="sxs-lookup"><span data-stu-id="ab905-138">You can deploy multiple VMs as Docker hosts and run any number of containers per VM.</span></span> <span data-ttu-id="ab905-139">次に、Azure Load Balancer を使用すると、図 4-3 に示すようにスケーリングを管理できます。</span><span class="sxs-lookup"><span data-stu-id="ab905-139">Then, by using an Azure Load Balancer, as illustrated in the Figure 4-3, you can manage scaling.</span></span>

![モノリシック アプリできますスケール アウトするのには、それぞれが実行されているアプリのコンテナーで別のホスト。](./media/image3.png)

<span data-ttu-id="ab905-141">**図 4-3**</span><span class="sxs-lookup"><span data-stu-id="ab905-141">**Figure 4-3**.</span></span> <span data-ttu-id="ab905-142">Docker アプリケーションのアプリ/コンテナーが 1 つをスケール アウトの複数のホスト</span><span class="sxs-lookup"><span data-stu-id="ab905-142">Multiple hosts scaling-out a single Docker application apps/containers</span></span>

<span data-ttu-id="ab905-143">従来の展開手法を使用して、ホスト自体の展開を管理することができます。</span><span class="sxs-lookup"><span data-stu-id="ab905-143">You can manage the deployment of the hosts themselves via traditional deployment techniques.</span></span>

<span data-ttu-id="ab905-144">ようなコマンドを使用して、コマンドラインから Docker コンテナーを管理する`docker run`と`docker-compose up`も継続的デリバリー (CD) パイプラインを自動化することを Azure DevOps サービスからのインスタンスを Docker ホストに展開できます。</span><span class="sxs-lookup"><span data-stu-id="ab905-144">You can manage Docker containers from the command line by using commands like `docker run` and `docker-compose up`, and you can also automate it in Continuous Delivery (CD) pipelines and deploy to Docker hosts from Azure DevOps Services, for instance.</span></span>

## <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="ab905-145">コンテナーとして展開するモノリシック アプリケーション</span><span class="sxs-lookup"><span data-stu-id="ab905-145">Monolithic application deployed as a container</span></span>

<span data-ttu-id="ab905-146">モノリシック展開を管理するコンテナーを使用する利点があります。</span><span class="sxs-lookup"><span data-stu-id="ab905-146">There are benefits to using containers to manage monolithic deployments.</span></span> <span data-ttu-id="ab905-147">コンテナーのインスタンスをスケーリングする処理は、追加の VM を展開するよりもはるかに高速で簡単です。</span><span class="sxs-lookup"><span data-stu-id="ab905-147">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span>

<span data-ttu-id="ab905-148">更新プログラムを Docker イメージとして展開する方がはるかに高速で、ネットワークの効率が高くなります。</span><span class="sxs-lookup"><span data-stu-id="ab905-148">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="ab905-149">Docker コンテナーは、通常の展開を高速化、秒単位で開始します。</span><span class="sxs-lookup"><span data-stu-id="ab905-149">Docker containers typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="ab905-150">呼び出しと同じくらい簡単では、Docker コンテナーの破棄、`docker stop`コマンドは、通常は 1 秒未満で完了します。</span><span class="sxs-lookup"><span data-stu-id="ab905-150">Tearing down a Docker container is as easy as invoking the `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="ab905-151">コンテナーが本質的に、設計上不変なので、決して更新スクリプトをいくつかの特定の構成またはファイルがディスク上の残りのアカウントを忘れたために、Vm の破損について心配する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ab905-151">Because containers are inherently immutable, by design, you never need to worry about corrupted VMs because an update script forgot to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="ab905-152">モノリシック アプリケーションは Docker の恩恵がメリットのヒントのみ面しています。</span><span class="sxs-lookup"><span data-stu-id="ab905-152">Although monolithic apps can benefit from Docker, we're touching on only the tips of the benefits.</span></span> <span data-ttu-id="ab905-153">コンテナーの管理の大きな利点は、さまざまなインスタンスと各コンテナー インスタンスのライフ サイクルを管理するコンテナー オーケストレーターに展開するから取得されます。</span><span class="sxs-lookup"><span data-stu-id="ab905-153">The larger benefits of managing containers come from deploying with container orchestrators that manage the various instances and life cycle of each container instance.</span></span> <span data-ttu-id="ab905-154">モノリシック アプリケーションを、スケーリング、開発、および展開を個別に実行できるサブシステムに分割することが、マイクロサービスの領域への入り口になります。</span><span class="sxs-lookup"><span data-stu-id="ab905-154">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

<span data-ttu-id="ab905-155">コンテナーでモノリシック アプリケーションを「リフト アンド シフト」し、アプリケーションを最新化する方法する方法の詳細については、この追加の Microsoft のガイドを参照して[Azure クラウドおよび Windows コンテナーで既存の .NET アプリケーションを近代化](https://docs.microsoft.com/dotnet/standard/modernize-with-azure-and-containers/)から PDF としてダウンロードすることもできます。 を<https://aka.ms/LiftAndShiftWithContainersEbook>します。</span><span class="sxs-lookup"><span data-stu-id="ab905-155">To learn about how to “lift and shift” monolithic applications with containers and how you can modernize your applications, you can read this additional Microsoft guide, [Modernize existing .NET applications with Azure cloud and Windows Containers](https://docs.microsoft.com/dotnet/standard/modernize-with-azure-and-containers/), that you can also download as PDF from <https://aka.ms/LiftAndShiftWithContainersEbook>.</span></span>

## <a name="publish-a-single-docker-container-app-to-azure-app-service"></a><span data-ttu-id="ab905-156">Azure App Service への 1 つの Docker コンテナー アプリを発行します。</span><span class="sxs-lookup"><span data-stu-id="ab905-156">Publish a single Docker container app to Azure App Service</span></span>

<span data-ttu-id="ab905-157">いずれかを Azure にデプロイされたコンテナーのクイック検証を取得するか、アプリ、単に単一のコンテナー アプリを Azure App Services は、スケーラブルな単一のコンテナー サービスを提供する優れた方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="ab905-157">Either because you want to get a quick validation of a container deployed to Azure or because the app is simply a single-container app, Azure App Services provides a great way to provide scalable single-container services.</span></span>

<span data-ttu-id="ab905-158">直感的に Azure App Service を使用してとさせることができ、優れた Git を提供するため、迅速に実行されているコードへの統合は Microsoft Visual studio でビルドし、直接 Azure にデプロイします。</span><span class="sxs-lookup"><span data-stu-id="ab905-158">Using Azure App Service is intuitive and you can get up and running quickly because it provides great Git integration to take your code, build it in Microsoft Visual Studio, and directly deploy it to Azure.</span></span> <span data-ttu-id="ab905-159">従来 (Docker を使用しない) 必要があるその他の機能、フレームワーク、または依存関係では、App Services でサポートされていない場合、Azure チームは、App Service でこれらの依存関係を更新するまで待機するために必要かなどの他のサービスに切り替えることが、Service Fabric、Cloud Services、またはプレーン Vm、対象のコントロールをさらがあるし、アプリケーションの必要なコンポーネントやフレームワークをインストールできます。</span><span class="sxs-lookup"><span data-stu-id="ab905-159">But, traditionally (with no Docker), if you needed other capabilities, frameworks, or dependencies that aren't supported in App Services, you needed to wait for it until the Azure team updates those dependencies in App Service or switched to other services like Service Fabric, Cloud Services, or even plain VMs, for which you have further control and can install a required component or framework for your application.</span></span>

<span data-ttu-id="ab905-160">図 4-4 に示すように、今すぐ Visual Studio 2017 を使用して Azure App Service でコンテナー サポートが得られます app 環境内で何でもを含むことのできます。</span><span class="sxs-lookup"><span data-stu-id="ab905-160">Now, as shown in Figure 4-4, when using Visual Studio 2017, container support in Azure App Service gives you the ability to include whatever you want in your app environment.</span></span> <span data-ttu-id="ab905-161">コンテナーで実行しているため、アプリに依存関係を追加した場合、ファイルまたは Docker イメージでこれらの依存関係をなどの機能を取得します。</span><span class="sxs-lookup"><span data-stu-id="ab905-161">If you added a dependency to your app, because you are running it in a container, you get the capability of including those dependencies in your Dockerfile or Docker image.</span></span>

![コンテナー レジストリのセレクターを強調表示、Azure app service に発行する Visual Studio のウィザードのビュー。](./media/image4.png)

<span data-ttu-id="ab905-163">**図 4-4**</span><span class="sxs-lookup"><span data-stu-id="ab905-163">**Figure 4-4**.</span></span> <span data-ttu-id="ab905-164">Visual Studio のアプリ/コンテナーから Azure App Service にコンテナーを発行する.</span><span class="sxs-lookup"><span data-stu-id="ab905-164">Publishing a container to Azure App Service from Visual Studio apps/containers</span></span>

<span data-ttu-id="ab905-165">図 4-4 も発行フローが Azure Container Registry (レジストリを Azure 内の展開に近く、および Azure Active Directory グループとアカウントによって保護された) は、コンテナー レジストリをまたはその他の任意の Docker レジストリを介してイメージをプッシュすることを示していますDocker Hub やオンプレミス レジストリなど。</span><span class="sxs-lookup"><span data-stu-id="ab905-165">Figure 4-4 also shows that the publish flow pushes an image through a Container Registry, which can be the Azure Container Registry (a registry near to your deployments in Azure and secured by Azure Active Directory groups and accounts) or any other Docker Registry like Docker Hub or on-premises registries.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="ab905-166">[前へ](common-container-design-principles.md)
>[次へ](state-and-data-in-docker-applications.md)</span><span class="sxs-lookup"><span data-stu-id="ab905-166">[Previous](common-container-design-principles.md)
[Next](state-and-data-in-docker-applications.md)</span></span>
