---
title: TypeConverters および XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 29286328c960707151fd5b6f2804346373000ad4
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/23/2019
ms.locfileid: "54748078"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="fd1e0-102">TypeConverters および XAML</span><span class="sxs-lookup"><span data-stu-id="fd1e0-102">TypeConverters and XAML</span></span>
<span data-ttu-id="fd1e0-103">このトピックでは、一般的な XAML 言語機能として、文字列からの型変換の目的について説明します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="fd1e0-104">.NET Framework で、<xref:System.ComponentModel.TypeConverter>クラスは、特定の目的を XAML 属性の使用法のプロパティの値として使用できる管理対象のカスタム クラスの実装の一部として機能します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="fd1e0-105">カスタム クラスを作成する XAML 設定可能な属性の値として使用するのには、クラスのインスタンスが必要な場合は、可能性があります、適用する必要があります、<xref:System.ComponentModel.TypeConverterAttribute>カスタムを作成し、クラスに<xref:System.ComponentModel.TypeConverter>クラス、またはその両方です。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  
  

  
## <a name="type-conversion-concepts"></a><span data-ttu-id="fd1e0-106">型変換の概念</span><span class="sxs-lookup"><span data-stu-id="fd1e0-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="fd1e0-107">XAML と文字列値</span><span class="sxs-lookup"><span data-stu-id="fd1e0-107">XAML and String Values</span></span>  
 <span data-ttu-id="fd1e0-108">XAML ファイルで属性値を設定するときは、その値の最初の型では、文字列が純粋なテキストです。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="fd1e0-109">などの他のプリミティブ<xref:System.Double>最初は XAML プロセッサにテキスト文字列です。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="fd1e0-110">XAML プロセッサには、属性値を処理するために 2 つの情報が必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="fd1e0-111">第 1 の情報は、設定しようとしているプロパティの値の型です。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="fd1e0-112">属性値を定義するすべての文字列は、XAML で処理され、最終的にはその型の値に変換 (解決) される必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="fd1e0-113">値が、XAML パーサーで認識できるプリミティブ (数値など) である場合は、文字列の直接的な変換が試みられます。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="fd1e0-114">値が列挙体の場合は、文字列を使用して、その列挙体の名前付き定数に一致する名前を確認してください。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="fd1e0-115">値がどちらもパーサーで認識されるプリミティブも列挙体は、その問題の型の場合は、型、または変換後の文字列に基づいて、値のインスタンスを提供できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="fd1e0-116">これは、型コンバーターのクラスを示すことにより行います。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="fd1e0-117">型コンバーターは、事実上、コードが .NET コードの呼び出しに対する XAML シナリオとも可能性がある別のクラスの値を提供するためのヘルパー クラスです。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="fd1e0-118">XAML で既存の型変換動作を使用します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="fd1e0-119">基になる XAML の概念に関する知識、に応じてする可能性があります既に型変換動作アプリケーションで使用する基本的な XAML 気付かないうちに。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="fd1e0-120">たとえば、WPF は型の値を使用するプロパティの百を定義します。<xref:System.Windows.Point>します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="fd1e0-121">A <xref:System.Windows.Point> 2 次元の座標空間内の座標を記述する値は、2 つの重要なプロパティが実際には:<xref:System.Windows.Point.X%2A>と<xref:System.Windows.Point.Y%2A>します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="fd1e0-122">XAML の時点を指定するときに指定する区切り記号 (コンマ) を使って文字列としての間、<xref:System.Windows.Point.X%2A>と<xref:System.Windows.Point.Y%2A>指定する値。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="fd1e0-123">たとえば、`<LinearGradientBrush StartPoint="0,0" EndPoint="1,1">` のように指定します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1">`.</span></span>  
  
 <span data-ttu-id="fd1e0-124">この単純な種類のでも<xref:System.Windows.Point>XAML における単純な使用法が型コンバーターが含まれるとします。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="fd1e0-125">この場合、クラスは<xref:System.Windows.PointConverter>します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="fd1e0-126">型コンバーター<xref:System.Windows.Point>マークアップの使用方法を使用するすべてのプロパティのクラス レベルの効率で定義されている<xref:System.Windows.Point>します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="fd1e0-127">せず、型コンバーターは、ここでは次のとおり、前述の同じ例のマークアップをかなり詳細。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  
  
 `<LinearGradientBrush>`  
  
 `<LinearGradientBrush.StartPoint>`  
  
 `<Point X="0" Y="0"/>`  
  
 `</LinearGradientBrush.StartPoint>`  
  
 `<LinearGradientBrush.EndPoint>`  
  
 `<Point X="1" Y="1"/>`  
  
 `</LinearGradientBrush.EndPoint>`  
  
 `<LinearGradientBrush>`  
  
 <span data-ttu-id="fd1e0-128">文字列型の変換または同等のより詳細な構文を使用するかどうかは、一般に、コーディング スタイル選択です。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="fd1e0-129">XAML ツールのワークフローが値の設定方法に影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="fd1e0-130">一部の XAML ツールは、デザイナーのビューや、独自のシリアル化メカニズムへのラウンドト リップする使いやすいために、最も詳細な形式のマークアップを出力する傾向があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="fd1e0-131">既存の型コンバーターは一般に、適用の有無クラス (またはプロパティ) をチェック WPF と .NET Framework の型で検出された<xref:System.ComponentModel.TypeConverterAttribute>します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="fd1e0-132">この属性は、クラスの XAML の目的だけでなく可能性のある他の目的で、その型の値のサポート型コンバーターの名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="fd1e0-133">型コンバーターとマークアップ拡張機能</span><span class="sxs-lookup"><span data-stu-id="fd1e0-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="fd1e0-134">マークアップ拡張機能よぶ型コンバーターは、XAML プロセッサの動作とに適用するシナリオの観点から両方の役割を入力します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="fd1e0-135">マークアップ拡張機能の使用時にはコンテキストを利用できますが、マークアップ拡張機能が値を提供するプロパティの型変換動作は一般にマークアップ拡張機能の実装ではチェックされません。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="fd1e0-136">つまり、マークアップ拡張機能としてテキスト文字列を返した場合であってもその`ProvideValue`出力するには、特定のプロパティまたはプロパティ値の型に適用されると、その文字列に対する型変換動作は呼び出されません、一般に、マークアップ拡張機能の目的は、プロセスには、文字列と関連する型コンバーターを呼び出さず、オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="fd1e0-137">マークアップ拡張機能が型コンバーターではなく必要な場合、1 つの一般的な状況は既に存在するオブジェクトへの参照です。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="fd1e0-138">せいぜい、ステートレスな型コンバーターは、望ましいことができない可能性がありますの新しいインスタンスを生成のみでした。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="fd1e0-139">マークアップ拡張機能の詳細については、次を参照してください。[マークアップ拡張機能と WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="fd1e0-140">ネイティブな型コンバーター</span><span class="sxs-lookup"><span data-stu-id="fd1e0-140">Native Type Converters</span></span>  
 <span data-ttu-id="fd1e0-141">XAML パーサーの WPF と .NET Framework の実装では、ネイティブ型の変換処理、まだがプリミティブとして考えるが従来どおり型ではない特定の種類があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="fd1e0-142">このような型の例として、 <xref:System.DateTime>が挙げられます。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="fd1e0-143">この理由は、.NET Framework のアーキテクチャの動作方法に基づきは: 種類<xref:System.DateTime>mscorlib、.NET で最も基本的なライブラリで定義されます。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="fd1e0-144"><xref:System.DateTime> 属性、依存関係を導入する別のアセンブリから来る属性を設定するのには許可されていません (<xref:System.ComponentModel.TypeConverterAttribute>は System から) ため、属性によって、通常の型コンバーターの検出メカニズムがサポートされることはできません。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="fd1e0-145">代わりに、XAML パーサーでは、このようなネイティブの処理が必要な型のリストがあるし、通常のプリミティブの処理方法と同様にこれらを処理します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="fd1e0-146">(の場合に<xref:System.DateTime>への呼び出しは、 <xref:System.DateTime.Parse%2A>)。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>   
## <a name="implementing-a-type-converter"></a><span data-ttu-id="fd1e0-147">型コンバーターの実装</span><span class="sxs-lookup"><span data-stu-id="fd1e0-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="fd1e0-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="fd1e0-148">TypeConverter</span></span>  
 <span data-ttu-id="fd1e0-149"><xref:System.Windows.Point>以前は、クラスの例<xref:System.Windows.PointConverter>が説明したようにします。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="fd1e0-150">XAML の目的で使用されるすべての型コンバーターは、基底クラスから派生するクラスを XAML の .NET 実装の<xref:System.ComponentModel.TypeConverter>します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="fd1e0-151"><xref:System.ComponentModel.TypeConverter>クラスは、XAML の存在の前のバージョンの .NET Framework に存在していた; ビジュアル デザイナーでのプロパティ ダイアログ ボックスの文字列変換を提供するその元の使用法の 1 つでした。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="fd1e0-152">XAML の役割の<xref:System.ComponentModel.TypeConverter>を拡張して、文字列の属性値を解析し、可能性がありますの文字列に特定のオブジェクトのプロパティの実行時の値を処理できるようにする文字列に変換して、文字列からの変換の基本クラスには、属性としてシリアル化します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="fd1e0-153"><xref:System.ComponentModel.TypeConverter> XAML 処理の目的の文字列から変換するために関連する 4 つのメンバーを定義します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
-   <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="fd1e0-154">最も重要なメソッドは、これらのうち、<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="fd1e0-155">このメソッドは、入力文字列を必要なオブジェクト型に変換します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="fd1e0-156">厳密に言えば、<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>幅広い範囲の型をコンバーターの目的の型に変換、そのため、実行時の変換をサポートするなど、XAML の目的で XAML 以外の目的を提供するメソッドを実装する可能性があります処理できるコード パスのみである、<xref:System.String>重要な入力します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="fd1e0-157">[次へ] の最も重要なメソッドは<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="fd1e0-158">かどうか、アプリケーションは、マークアップ表現に変換されます (たとえば、ファイルとして XAML に保存されます) 場合、<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>はマークアップ表現を生成を担当します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="fd1e0-159">この場合は、XAML の重要なコード パスは、渡すときに、`destinationType`の<xref:System.String>します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="fd1e0-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> と <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> は、サービスが <xref:System.ComponentModel.TypeConverter> の実装の機能を照会する時に使用されるサポート メソッドです。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="fd1e0-161">これらのメソッドは、その型について、相当する変換メソッドをコンバーターがサポートしている場合に `true` を返すように実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="fd1e0-162">XAML の目的では、通常、 <xref:System.String> 型であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="fd1e0-163">カルチャ情報と XAML の型コンバーター</span><span class="sxs-lookup"><span data-stu-id="fd1e0-163">Culture Information and Type Converters for XAML</span></span>  
 <span data-ttu-id="fd1e0-164">各<xref:System.ComponentModel.TypeConverter>実装ことができます、変換に対して有効な文字列の構成要素の独自の解釈があるとも使用したり、パラメーターとして渡された型の説明を無視します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="fd1e0-165">カルチャと XAML 型の変換に関して重要な考慮事項があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="fd1e0-166">XAML では、ローカライズ可能な文字列を使用して属性値としてはサポートされて完全。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="fd1e0-167">XAML 属性値の型コンバーターが、必ずしも特定の言語の解析動作が関与するための特定のカルチャ要件型コンバーターの入力がサポートされていないためにそのローカライズ可能な文字列を使用して、使用して、`en-US`カルチャ。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="fd1e0-168">この制限の設計上の理由の詳細については、XAML 言語仕様を参照してください ([\[MS XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525))。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525)).</span></span>  
  
 <span data-ttu-id="fd1e0-169">カルチャが問題になることなどに、一部のカルチャが数値の小数点記号としてコンマを使用します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="fd1e0-170">WPF XAML の型コンバーターの多くが、これは、区切り記号としてコンマを使用する動作と競合がこの (一般的な X などの従来の慣習に基づき、Y フォーム、またはコンマ区切りリスト)。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="fd1e0-171">周囲の XAML でカルチャを渡すことも (設定`Language`または`xml:lang`を`sl-SI`カルチャ、この方法で小数点のコンマを使用するカルチャの例) で問題が解決しません。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="fd1e0-172">ConvertFrom の実装</span><span class="sxs-lookup"><span data-stu-id="fd1e0-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="fd1e0-173">XAML をサポートする <xref:System.ComponentModel.TypeConverter> の実装としてコンバーターを使用できるようにするためには、そのコンバーターの <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> メソッドが `value` パラメーターとして文字列を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="fd1e0-174">書式設定、およびによって変換できる有効な文字列がかどうか、<xref:System.ComponentModel.TypeConverter>実装し、返されたオブジェクトはプロパティによって予期される型へのキャストをサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="fd1e0-175">それ以外の場合、 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 実装は `null`を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="fd1e0-176">各<xref:System.ComponentModel.TypeConverter>実装ことができます、変換に対して有効な文字列の構成要素の独自の解釈があるとも使用したり、パラメーターとして渡された型の説明やカルチャ コンテキストを無視します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="fd1e0-177">ただし、処理、WPF XAML の場合は、型の説明コンテキストに値を渡さない場合がありますに基づくカルチャを渡さない場合がありますも`xml:lang`します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fd1e0-178">特に、中かっこ文字を使用しないでください {、文字列の書式の要素として。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="fd1e0-179">これらの文字は、マークアップ拡張シーケンスの開始および終了を示す文字として予約されています。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="fd1e0-180">ConvertTo の実装</span><span class="sxs-lookup"><span data-stu-id="fd1e0-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="fd1e0-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> は、シリアル化のサポートで使用される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="fd1e0-182">カスタム型およびその型コンバーターに対して <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> によるシリアル化をサポートすることは、絶対要件ではありません。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="fd1e0-183">ただし、コントロールを実装する場合、またはクラスの機能または設計の一部としてシリアル化を使用する場合は、 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="fd1e0-184">として使用するのには、 <xref:System.ComponentModel.TypeConverter> 、XAML をサポートする実装、<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>としてそのコンバーターのメソッドがサポートされている型 (または値) のインスタンスを受け入れる必要があります、`value`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="fd1e0-185">ときに、`destinationType`パラメーターは、型<xref:System.String>、返されるオブジェクトとしてキャストできる必要がありますし、<xref:System.String>します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="fd1e0-186">返される文字列は、 `value`のシリアル化された値を表している必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="fd1e0-187">理想的には、シリアル化形式を選択する必要がありますにその文字列が渡された場合は、同じ値を生成できるが、<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>重要な情報が失われることがなく、同じコンバーターの実装。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="fd1e0-188">値をシリアル化することはできません、またはコンバーターがシリアル化をサポートしていない場合、<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>実装を返す必要があります`null`、ここでは例外をスローすることはできます。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="fd1e0-189">例外をスローする場合は、一部としてその変換を使用できないことを報告する必要がありますが、<xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>実装ようにチェックのベスト プラクティス<xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>例外を回避するためにはサポートされて最初。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="fd1e0-190">場合`destinationType`型のパラメーターがない<xref:System.String>、独自のコンバーター処理を選択できます。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="fd1e0-191">通常、基本の実装、basemost での処理を元に戻すには<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>特定の例外を発生させます。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="fd1e0-192">CanConvertTo の実装</span><span class="sxs-lookup"><span data-stu-id="fd1e0-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="fd1e0-193"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> の実装は、 `true` が `destinationType` 型の場合は <xref:System.String>を返し、それ以外の場合は基底の実装に任せる必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="fd1e0-194">CanConvertFrom の実装</span><span class="sxs-lookup"><span data-stu-id="fd1e0-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="fd1e0-195"><xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> の実装は、 `true` が `sourceType` 型の場合は <xref:System.String>を返し、それ以外の場合は基底の実装に任せる必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>   
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="fd1e0-196">TypeConverterAttribute の適用</span><span class="sxs-lookup"><span data-stu-id="fd1e0-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="fd1e0-197">カスタム型コンバーターとして使用するために適用する必要があります、XAML プロセッサによってカスタム クラスの型コンバーター、 [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute>クラス定義にします。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="fd1e0-198">属性を通して指定する <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> は、カスタム型コンバーターの型名である必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="fd1e0-199">この属性を適用するには、XAML プロセッサは、プロパティの型が、カスタム クラスの型を使用して値を処理する場合、入力文字列と、オブジェクトのインスタンスを返します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="fd1e0-200">また、プロパティごとに型コンバーターを提供することもできます。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="fd1e0-201">クラス定義に [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> を適用する代わりに、プロパティ定義 (メイン定義内の `get`/`set` 実装ではなくメイン定義自体) に適用します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-201">Instead of applying a [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="fd1e0-202">プロパティの型は、カスタム型コンバーターによって処理される型と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="fd1e0-203">この属性を適用するには、Xaml では、そのプロパティの値を処理する場合、入力文字列を処理し、オブジェクト インスタンスを返します。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-203">With this attribute applied, when a XAMLprocessor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="fd1e0-204">プロパティの型コンバーターの手法は Microsoft .NET Framework とは、クラス定義を制御することはできませんし、適用できません他のいくつかのライブラリからプロパティの型を使用する場合に特に便利です、<xref:System.ComponentModel.TypeConverterAttribute>があります。</span><span class="sxs-lookup"><span data-stu-id="fd1e0-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fd1e0-205">関連項目</span><span class="sxs-lookup"><span data-stu-id="fd1e0-205">See also</span></span>
- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="fd1e0-206">XAML の概要 (WPF)</span><span class="sxs-lookup"><span data-stu-id="fd1e0-206">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)
- [<span data-ttu-id="fd1e0-207">マークアップ拡張機能と WPF XAML</span><span class="sxs-lookup"><span data-stu-id="fd1e0-207">Markup Extensions and WPF XAML</span></span>](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="fd1e0-208">XAML 構文の詳細</span><span class="sxs-lookup"><span data-stu-id="fd1e0-208">XAML Syntax In Detail</span></span>](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)
