---
title: F# の関数型プログラミングの概要
description: 関数型プログラミングの基礎を学習F#します。
ms.date: 10/29/2018
ms.openlocfilehash: d4a9bb0cd826b41aca96e12e2bcb5aab80c18eb4
ms.sourcegitcommit: db8b83057d052c1f9f249d128b08d4423af0f7c2
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/02/2018
ms.locfileid: "25724479"
---
# <a name="introduction-to-functional-programming-in-f"></a>F# の関数型プログラミングの概要 #

関数型プログラミングは、機能と変更不可のデータの使用を重視するプログラミングのスタイルです。 型指定された関数型プログラミングは関数型プログラミングと組み合わせると静的な型などとF#します。 一般に、次の概念が関数型プログラミングで強調表示します。

* 使用する基本的な構造と機能
* ステートメントではなく式
* 変数に値を変更できません。
* 宣言型のプログラミング命令型プログラミングの概要

この連載では、概念、および関数型プログラミングを使用してパターンをについて説明しますF#します。 その過程でいくつか説明しますF#すぎます。

## <a name="terminology"></a>用語

その他のプログラミング パラダイムのように、関数型プログラミングを学習する必要が最終的にボキャブラリが付属します。 ここでは、いくつかの一般的な用語、時間のすべてが表示されます。

* **関数**-関数がコンス トラクターを指定した入力と出力を生成します。 正式には、その_マップ_いずれかから項目を別のセットに設定します。 この形式は、データのコレクションを操作する関数を使用する際に特に多くの点で具象型にリフトされます。 これは、関数型プログラミングで最も基本的な (かつ重要な) 概念です。 
* **式**-式は、値を生成するコードでコンス トラクター。 F#、この値をバインドまたは明示的に無視する必要があります。 式は、関数呼び出しによって普通に交換できます。
* **純粋性**-純粋性のある関数のプロパティの戻り値は常に同じ引数を同じとその評価に副作用がありません。 純粋関数は、その引数に完全に依存します。
* **参照の透過性**-プログラムの動作に影響を与えずにその出力を交換できるように参照の透過性は式のプロパティです。
* **不変性**の不変性という値にすることはできませんが、インプレースを変更します。 これは、変数で、インプレース変更できるとは対照的です。

## <a name="examples"></a>使用例

次の例では、これらの主要な概念を示します。

### <a name="functions"></a>関数

関数型プログラミングの最も一般的なと基本的な構造は、関数です。 整数値に 1 を追加する単純な関数を次に示します。

```fsharp
let addOne x = x + 1
```

その型のシグネチャは次のとおりです。

```fsharp
val addOne: x:int -> int
```

として、署名を読み取ることができます"`addOne`を受け入れる、`int`という名前の`x`が生成されますと、 `int`"。 正式には、`addOne`は_マッピング_一連の整数に整数のセットからの値。 `->`トークンは、このマッピングを示します。 F#、通常、処理の内容を把握関数のシグネチャを見てすることができます。

そのためが署名重要な理由ですか。 型指定された関数型プログラミング、関数の実装が多くの場合、小さい実際の型シグネチャよりも重要です。 という事実を`addOne`、実行時に興味深いは、整数値 1 を追加します。 という事実を受け入れて返すそのプログラムを構築する場合は、`int`はどのような通知、この関数を実際に使用する方法。 さらに、正しく (その型のシグネチャ) に関しては、この関数を使用すると、すべての問題を診断できますの本文内でのみ、`addOne`関数。 これは、型指定された関数型プログラミングの背後にある材料です。

### <a name="expressions"></a>式

式は、値に評価する構成要素です。 ステートメントで、アクションを実行するとは対照的の値を提供するアクションを実行する式を考えることができます。 式は、関数型プログラミングでステートメントを優先してほとんどの場合に使用されます。

前の関数について考えてみます`addOne`します。 本文`addOne`式です。

```fsharp
// 'x + 1' is an expression!
let addOne x = x + 1
```

結果型を定義する、この式の結果は、`addOne`関数。 たとえばなど別の種類を指定するこの関数を構成する式を変更できます、 `string`:

```fsharp
let addOne x = x.ToString() + "1"
```

関数のシグネチャは、ようになりました。

```fsharp
val addOne: x:'a -> string
```

以降のすべての種類F#が`ToString()`上の型と呼ばれる`x`ジェネリックが行わ (と呼ばれる[自動ジェネリック化](../language-reference/generics/automatic-generalization.md))、し、結果の型は、 `string`。

式は関数の本体だけではありません。 式が別の場所を使用する値を生成することができます。 共通の 1 つは`if`:

```fsharp
// Checks if 'x' is odd by using the mod operator
let isOdd x = x % 2 <> 0

let addOneIfOdd input =
    let result =
        if isOdd input then
            input + 1
        else
            input

    result
```

`if`式と呼ばれる値を生成`result`します。 省略することに注意してください`result`完全に行う、`if`式本体の`addOneIfOdd`関数。 式について覚えておくべき重要な点は、値を生成することです。

特殊な種類がある`unit`、nothing を返しますを使用する必要がある場合に使用されます。 たとえば、この単純な関数があるとします。

```fsharp
let printString (str: string) =
    printfn "String is: %s" s
```

署名のようになります。

```fsharp
val printString: str:string -> unit
```

`unit`型では、返される実際の値がないことを示します。 必要があるルーチンがある場合に便利ですが「作業」にもかかわらず、その作業結果として返される値を持たない。

これは、命令型プログラミングに対照的場所と同じ`if`コンストラクトとは、ステートメントと変数の変化でよく行われますが値を生成します。 たとえば、 C#、このようなコードを記述する場合があります。

```csharp
bool IsOdd(int x) => x % 2 != 0;

int AddOneIfOdd(int input)
{
    var result = input;

    if (IsOdd(input))
    {
        result = input + 1;
    }

    return result;
}
```

いることに注意がC#おり、他の C スタイル言語サポート、[三項式](../../csharp/language-reference/operators/conditional-operator.md)、式ベースの条件付きプログラミングのことができます。

関数型プログラミングで行うことはまれステートメントで値を変更します。 ステートメントと変異をいくつかの関数型言語をサポート関数型プログラミングでこれらの概念を使用する一般的なことはありません。

### <a name="pure-functions"></a>純粋関数

前に説明した、純粋関数は、関数します。

* 常に同じ入力に対して同じ値に評価します。
* 副作用があるありません。

このコンテキストの数学関数と考えることをお勧めします。 数学では、関数は、引数にのみ依存し、は、副作用はありません。 数学関数で`f(x) = x + 1`の値`f(x)`の値にのみ依存`x`します。 純粋関数型プログラミングでは、同じ方法です。

純粋関数を記述するときに関数は引数のみに依存し、結果、副次的になる任意のアクションを実行する必要があります。

次のグローバルな変更可能な状態に依存するために非純粋関数の例を示します。

```fsharp
let mutable value = 1

let addOneToValue x = x + value
```

`addOneToValue`関数が明確に純粋なため、 `value` 1 よりも異なる値を設定するには、いつでも変更できます。 グローバル値に応じてのこのパターンでは、関数型プログラミングに回避されます。

次の副作用を実行するための非純粋関数では、別の例に示します。

```fsharp
let addOneToValue x = 
    printfn "x is %d" x
    x + 1
```

値を書き込むが、この関数は、グローバルな値に依存しない、`x`プログラムの出力にします。 これを行うには本質的に問題はありませんが、関数が純粋でないことわけです。

削除、`printfn`ステートメント最後には、関数は、純粋な。

```fsharp
let addOneToValue x = x + 1
```

この機能は本質的には_優れた_で以前のバージョンよりも、`printfn`ステートメントでは、その値を返すこの関数はすべて、保証は。 この関数を呼び出す関数の 1 回または 1 90億回は同じでも結果: 同じ値を生成します。 この予測は、任意の純粋関数がしいものに透過的なことを意味するために関数型プログラミングで重要です。

### <a name="referential-transparency"></a>参照の透過性

参照の透過性は、式と関数のプロパティです。 透明しいものである式をプログラムの動作を変更することがなく、結果の値に置き換えることがある場合があります。 すべての純粋関数では、しいもの透過的です。

純粋関数と同様は数学的な観点からは参照の透過性を考えることができます。 算術式で`y = f(x)`、`f(x)`関数の結果を置き換えと等しくあってはまだ`y`します。 これは関数型プログラミングで参照の透過性を均等に当てはまります。

以前に定義されたを呼び出してください`addOneIfOdd`関数を 2 回。

```fsharp
// Checks if 'x' is odd by using the mod operator
let isOdd x = x % 2 <> 0

let addOneIfOdd input =
    let result =
        if isOdd input then
            input + 1
        else
            input

    result

let res1 = addOneIffOdd 1 // Produces 2
let res2 = addOneIffOdd 2 // Produces 2
```

引数の置換、関数本体の各関数呼び出しを置き換えることができます`input`個々 の値。

```fsharp
// Checks if 'x' is odd by using the mod operator
let isOdd x = x % 2 <> 0

let addOneIfOdd input =
    let result =
        if isOdd input then
            input + 1
        else
            input

    result

let res1 =
    let result =
        if isOdd 1 then
            1 + 1
        else
            1

    result
let res2 =
    let result =
        if isOdd 2 then
            2 + 1
        else
            2

    result
```

両方`res1`と`res2`関数が呼び出されたことを示す場合と同じ値を持つ`addOneIfOdd`はしいものに対して透過的です。

さらに、関数は、純粋にも、透過的なしいものにありません。 以前の定義を検討してください`addOneTovalue`:。

```fsharp
let addOneToValue x = 
    printfn "x is %d" x
    x + 1
```

この関数への呼び出しは、その本体で置き換えることもでき、同じ処理には、毎回が行われます。

* 出力に、追加される前に、値が出力されます。
* 値が 1 の追加

プログラミングするときF#、純粋性ではなく、目標は、参照の透過性がよくあります。 ただし、可能な場合に、純粋関数を記述することをおすすめなります。

### <a name="immutability"></a>不変性

最後に、型指定された関数型プログラミングの最も基本的な概念の 1 つは不変です。 F#、すべての値は既定では変更できません。 つまり、明示的にマークを付ける変更可能な場合を除き、インプレースで変換をすることはできません。

実際には、変更不可の値の操作は、ことから、「何かを変更する必要があります」プログラミングのアプローチを変更するに"べき新しい値を生成するためを意味します。

たとえば、値を追加する 1 いない既存の 1 つの変化、新しい値を生成を意味します。

```fsharp
let value = 1
let secondValue = value + 1
```

F#、コードを次に**いない**変異、`value`関数です。 は、等しいかどうかチェックを代わりに、が実行されます。

```fsharp
let value = 1
value = value + 1 // Produces a 'bool' value!
```

いくつかの関数型プログラミング言語は変化をまったくサポートしていません。 F#、可能ですが、値の既定の動作ではありません。

この概念は、データ構造のさらにも拡張します。 関数型プログラミングで不変のデータ構造セット (とさらに多く) 通常よりも最初に、さまざまな実装があるなど、期待しています。 概念的には、セットに項目を追加しても、セットが変更されないようになる、_新しい_追加された値に設定します。 実際には、これは多くの場合の結果として、データの適切な表現を指定できるように、値を効率的に追跡できるようにするさまざまなデータ構造で行います。

値とデータ構造の操作には、このスタイルは、この操作をするの新しいバージョンを作成する場合、何か変更する操作を扱うことを強制的に、重要です。 これにより、プログラムで一貫性のあるすべき点が等しいかどうかや比較など。

## <a name="next-steps"></a>次の手順

次のセクションは、関数、関数型プログラミングで使用することができます、さまざまな方法を調査を十分に説明します。

[ファーストクラス関数](first-class-functions.md)関数を深く、紹介さまざまなコンテキストで使用する方法を表示します。

## <a name="further-reading"></a>関連項目

[考える機能的](https://fsharpforfunandprofit.com/posts/thinking-functionally-intro/)シリーズは、関数型プログラミングの詳細については、別の優れたリソースF#します。 関数型プログラミングの基礎について説明します、pragmatic と読みやすい方法でを使用してF#な概念を説明する機能。