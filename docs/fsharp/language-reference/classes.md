---
title: クラス (F#)
description: F# クラスのプロパティ、メソッド、およびイベントを保持できるオブジェクトを表す型の方法について説明します。
ms.date: 05/16/2016
ms.openlocfilehash: 71cd713d192d28565e879b79b2fc9e0530e5f841
ms.sourcegitcommit: db8b83057d052c1f9f249d128b08d4423af0f7c2
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/02/2018
ms.locfileid: "48845737"
---
# <a name="classes"></a>クラス

*クラス*プロパティ、メソッド、およびイベントを保持できるオブジェクトを表す型。

## <a name="syntax"></a>構文

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a>Remarks

クラスは、.NET オブジェクト型の基本的な記述を表します。クラスは、f# オブジェクト指向プログラミングをサポートする型の主な概念です。

上記の構文、`type-name`は任意の有効な識別子です。 `type-params`省略可能なジェネリック型パラメーターについて説明します。 型パラメーター名と山かっこで囲まれた制約で構成されます (`<`と`>`)。 詳細については、次を参照してください。[ジェネリック](generics/index.md)と[制約](generics/constraints.md)します。 `parameter-list`コンス トラクターのパラメーターについて説明します。 最初のアクセス修飾子に関連する型。2 つ目は、プライマリ コンス トラクターに関するものです。 どちらの場合、既定値は`public`します。

クラスの基本クラスを使用して指定する、`inherit`キーワード。 基底クラスのコンス トラクターをかっこ内の引数を指定する必要があります。

フィールドを宣言するか、関数を使用して、クラスに対してローカルな値`let`バインディング、およびするが、一般的な規則に従う必要があります`let`バインドします。 `do-bindings`セクションには、オブジェクトの構築時に実行するコードが含まれています。

`member-list`の追加のコンス トラクター、インスタンスと静的メソッドの宣言、インターフェイス宣言、抽象バインドは、プロパティとイベントの宣言で構成されています。 後述[メンバー](members/index.md)します。

`identifier`オプションで使用されている`as`キーワードは、インスタンス変数、または型のインスタンスを参照する種類の定義で使用できる、自己識別子に名前を提供します。 詳細については、このトピックで後述する「自己識別子を参照してください。

キーワード`class`と`end`開始をマークして、定義の最後は省略可能です。

組み合わせて相互に参照型であり、再帰型が相互に参加している、`and`相互再帰関数と同じようにキーワード。 例については、「相互再帰型」を参照してください。

## <a name="constructors"></a>コンストラクター

コンス トラクターは、クラス型のインスタンスを作成するコードを示します。 これは、他の .NET 言語で、クラスのコンス トラクターは f# のやや異なる方法で機能します。 F# クラスでは常にプライマリ コンス トラクターの引数が記載されて、`parameter-list`続く型の名前、および本文から成る、 `let` (と`let rec`) バインドと、クラス宣言の先頭に`do`に従ってバインドします。 プライマリ コンス トラクターの引数は、クラス宣言全体のスコープになります。

使用して追加のコンス トラクターを追加することができます、`new`キーワードを次のように、メンバーを追加します。

`new`(`argument-list`) = `constructor-body`

新しいコンス トラクターの本文には、クラス宣言の上部にある指定されたプライマリ コンス トラクターを呼び出す必要があります。

次の例では、この概念を示します。 次のコードで`MyClass`2 つのコンス トラクターを持つ、2 つの引数と別のコンス トラクターを取得するプライマリ コンス トラクターは引数を受け取りません。

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a>使用して、do 束縛

`let`と`do`クラス定義内のバインディングは、主要なクラスのコンス トラクターの本体を形成し、したがって実行クラスのインスタンスが作成されるたびにします。 場合、`let`バインドが関数の場合、そのメンバーにコンパイルされます。 場合、`let`バインド関数またはメンバーで使用されていない値は、そのコンス トラクターにローカル変数にコンパイルされます。 それ以外の場合、クラスのフィールドにコンパイルされます。 `do`次の式は、プライマリ コンス トラクターにコンパイルされ、すべてのインスタンスの初期化コードを実行します。 追加のコンス トラクターは常に、プライマリ コンス トラクターを呼び出すので、`let`バインドと`do`コンス トラクターの呼び出しに関係なくバインドが常に実行します。

によって作成されるフィールド`let`バインド メソッドとクラスのプロパティを通じてアクセスできます。 ただし、アクセスできない、静的メソッドから静的メソッドがパラメーターとしてインスタンス変数を受け取る場合でもです。 1 つが存在する場合、自己識別子を使用してアクセスできません。

## <a name="self-identifiers"></a>自己識別子

A*自己識別子*は現在のインスタンスを表す名前です。 自己識別子のように、 `this` c# または C++ でキーワードまたは`Me`Visual Basic でします。 クラス定義全体または個々 のメソッドのためだけにスコープ内にある自己識別子にするかどうかに応じて、2 つの異なる方法では、自己識別子を定義できます。

クラス全体に対して自己識別子を定義するには、使用、`as`キーワードのコンス トラクターのパラメーターの閉じかっこの後に一覧表示、および識別子の名前を指定します。

1 つのメソッドの個人識別子を定義するには、メソッド名と、区切り記号としてピリオド (.) の直前に、メンバーの宣言で個人識別子を指定します。

次のコード例は、自己識別子を作成する 2 つの方法を示しています。 最初の行で、`as`キーワードの使用を自己識別子を定義します。 5 番目の行識別子で`this`スコープをメソッドに制限は、自己識別子を定義するために使用`PrintMessage`します。

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

異なり、他の .NET 言語で名前を指定できます、自己識別子; たいです。だけではない名前になど`self`、 `Me`、または`this`します。

宣言されている自己識別子、`as`までキーワードが初期化されていない後、`let`バインドが実行されます。 したがってで使用できませんが、`let`バインドします。 自己識別子を使用することができます、 `do` bindings セクション。

## <a name="generic-type-parameters"></a>ジェネリック型の型パラメーター

ジェネリック型パラメーターは山かっこで指定 (`<`と`>`)、単一引用符の後に、識別子の形式でします。 複数のジェネリック型パラメーターは、コンマで区切られます。 ジェネリック型パラメーターは、宣言全体のスコープ内です。 次のコード例では、ジェネリック型パラメーターを指定する方法を示します。

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

型を使用する場合、型引数が推論されます。 次のコードでは、推定された型は、タプルのシーケンスが。

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a>継承を指定します。

`inherit`句が 1 つを使用する必要がある場合、直接の基本クラスを識別します。 F# では、直接基底クラスを 1 つだけが許可されます。 クラスが実装するインターフェイスでは、基底クラスは考慮されません。 インターフェイスは、後ほど、[インターフェイス](Interfaces.md)トピック。

アクセスできますメソッドとプロパティの基本クラスの派生クラスから言語キーワードを使用して`base`、識別子としての後にピリオド (.) とメンバーの名前。

詳細については、「[継承](inheritance.md)」を参照してください。

## <a name="members-section"></a>メンバー セクション

このセクションでは、静的またはインスタンス メソッド、プロパティ、インターフェイスの実装、抽象メンバー、イベント宣言、および追加のコンス トラクターを定義できます。 使用して、バインドはこのセクションでは表示できません。 別のトピックで説明されている、メンバーは、さまざまなクラスのほか、f# の型に追加することができます、ため[メンバー](members/index.md)します。

## <a name="mutually-recursive-types"></a>相互再帰型

相互に循環的に参照型を定義するときにつなぎ合わせる種類の定義を使用して、`and`キーワード。 `and`キーワードに置き換えられます、`type`を次のように、最初の定義を除くすべてのキーワード。

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

出力は、現在のディレクトリ内のすべてのファイルの一覧を示します。

## <a name="when-to-use-classes-unions-records-and-structures"></a>クラス、共用体、レコード、および構造体を使用する場合

さまざまな種類から選択を指定するには、どのような各型の使用目的を特定の状況に適切な型を選択するをよく理解できる必要があります。 クラスはオブジェクト指向プログラミングのコンテキストで使用するために設計されています。 オブジェクト指向プログラミングとは、.NET Framework 向けに作成されたアプリケーションで使用される主要なパラダイムです。 F# コードは、.NET Framework または別のオブジェクト指向ライブラリと密接に連携する必要があり、UI ライブラリなど、オブジェクト指向型システムを拡張する必要がある場合は特に、クラスは、適切な可能性があります。

いない相互運用する密接にオブジェクト指向のコードでは、オブジェクト指向のコードの頻繁なやり取りからそのために保護され、自己完結型コードを記述する場合やは、レコードの使用を検討し、判別共用体。 1 つも思考 – アウト適切なパターン一致、コードと共に、判別共用体は、オブジェクトの階層構造を単純な代替手段としてよく使用できます。 判別共用体の詳細については、次を参照してください。[判別共用体](discriminated-unions.md)します。

レコードは、クラスよりも簡単になるというメリットが型の要求はその簡素性を実現できるを超えたときにレコードが適切でないです。 レコードは、基本的に単純な集計の値、カスタム アクションを実行できる別のコンス トラクターを持たない、隠しフィールド、および継承またはインターフェイスの実装を含まないです。 プロパティやメソッドなどのメンバーは、その動作をさらに複雑なレコードに追加できる、レコードに格納されているフィールドが値の単純な集計。 レコードの詳細については、次を参照してください。[レコード](records.md)します。

構造体も、データの小規模な集約に便利ですが、.NET 値型という点でクラスやレコードからが異なります。 クラスやレコードは、.NET 参照型です。 値型と参照型のセマンティクスは、値型は値によって渡される点で異なります。 つまり、コピーされるビット単位では、パラメーターとして渡されるまたは関数から返されます。 格納されるスタック上かの代わりに親オブジェクト内に埋め込まれた、フィールドとして使用される場合は、ヒープ上のそれぞれの場所に格納されています。 そのため、構造体は、ヒープへのアクセスのオーバーヘッドが問題と頻繁にアクセスされるデータに適しています。 構造体の詳細については、次を参照してください。[構造](structures.md)します。

## <a name="see-also"></a>関連項目

- [F# 言語リファレンス](index.md)
- [メンバー](members/index.md)
- [継承](inheritance.md)
- [インターフェイス](interfaces.md)
