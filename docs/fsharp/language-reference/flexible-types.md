---
title: フレキシブル型 (F#)
description: F# で柔軟な型注釈、パラメーター、変数、または値が指定した型と互換性がある型を持つことを示します。 これを使用する方法について説明します。
ms.date: 05/16/2016
ms.openlocfilehash: b6c97c3cc19f15b2c8db74b2c55660a16b2858f7
ms.sourcegitcommit: 5bbfe34a9a14e4ccb22367e57b57585c208cf757
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/18/2018
ms.locfileid: "45991026"
---
# <a name="flexible-types"></a>フレキシブル型

A*柔軟な型の注釈*パラメーター、変数、または値に互換性がクラスまたはインターフェイスのオブジェクト指向の階層内の位置によって決まりますが、種類を指定して互換性のある型があることを示します。 フレキシブル型は、型の階層で上位の型への自動変換は発生しませんが、階層内の任意の型またはインターフェイスを実装する任意の型を使用する、機能を有効にするときに特に便利です。

## <a name="syntax"></a>構文

```fsharp
#type
```

## <a name="remarks"></a>Remarks

前の構文で*型*基本データ型またはインターフェイスを表します。

柔軟な型では、基本またはインターフェイス型と互換性がある型に使用できる型を制限する制約を持つジェネリック型に相当します。 つまり、次の 2 行のコードは同等です。

```fsharp
#SomeType

'T when 'T :> SomeType
```

フレキシブル型は、いくつかの種類の状況で便利です。 たとえば、高階関数 (引数として関数を受け取る関数) を使用するは、柔軟な型を返す関数を用意すると便利は多くの場合。 次の例では、シーケンスに引数を持つ柔軟な型を使用して`iterate2`シーケンス、配列、リスト、およびその他の列挙可能な型を生成する関数を使用する、高階関数を使用します。

次の 2 つ関数のシーケンスを返しますが、柔軟な型を返しますが、その他のいずれかを検討してください。

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4101.fs)]

別の例として、 [Seq.concat](https://msdn.microsoft.com/library/2eeb69a9-fc2f-4b7d-8dee-101fa2b00712)ライブラリ関数。

```fsharp
val concat: sequences:seq<#seq<'T>> -> seq<'T>
```

次の列挙可能なシーケンスのいずれかは、この関数に渡すことができます。

- リストの一覧
- 配列の一覧
- リストの配列
- シーケンスの配列
- 列挙可能なシーケンスの他の任意の組み合わせ

次のコードでは`Seq.concat`に柔軟な型を使用してサポートできるシナリオについて説明します。

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4102.fs)]

出力は次のとおりです。

```
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
```

F# では、その他のオブジェクト指向言語のようにいくつかを派生型またはインターフェイスを実装する型が自動的に変換を基本データ型またはインターフェイス型のコンテキスト。 直接の引数が関数の型の戻り値の型などのより複雑な型の一部として、または型引数として、下位の位置での型がの場合は、これらの自動変換が発生します。 したがってに適用する型がより複雑な型の一部である場合は、柔軟な表記は主に役立ちます。

## <a name="see-also"></a>関連項目

- [F# 言語リファレンス](index.md)
- [ジェネリック](generics/index.md)
