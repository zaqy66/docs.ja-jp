---
title: '方法: 型の値の等価性を定義する (C# プログラミング ガイド)'
ms.date: 07/20/2015
helpviewer_keywords:
- overriding Equals method [C#]
- object equivalence [C#]
- Equals method [C#], overriding
- value equality [C#]
- equivalence [C#]
ms.assetid: 4084581e-b931-498b-9534-cf7ef5b68690
ms.openlocfilehash: 8abcace9c648ba2132d2b6849ae1c9d347d6fd29
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/10/2018
ms.locfileid: "53126784"
---
# <a name="how-to-define-value-equality-for-a-type-c-programming-guide"></a><span data-ttu-id="44b5a-102">方法: 型の値の等価性を定義する (C# プログラミング ガイド)</span><span class="sxs-lookup"><span data-stu-id="44b5a-102">How to: Define Value Equality for a Type (C# Programming Guide)</span></span>
<span data-ttu-id="44b5a-103">クラスまたは構造体を定義する場合は、型に値の等価性 (同値) のカスタム定義を作成することが有用かどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="44b5a-103">When you define a class or struct, you decide whether it makes sense to create a custom definition of value equality (or equivalence) for the type.</span></span> <span data-ttu-id="44b5a-104">通常、値の等価性を実装するのは、その型のオブジェクトがある種のコレクションに追加されることが想定されている場合、または、そのオブジェクトの主な目的が一連のフィールドまたはプロパティを格納することである場合です。</span><span class="sxs-lookup"><span data-stu-id="44b5a-104">Typically, you implement value equality when objects of the type are expected to be added to a collection of some sort, or when their primary purpose is to store a set of fields or properties.</span></span> <span data-ttu-id="44b5a-105">値の等価性は、型のすべてのフィールドおよびプロパティの比較に基づいて定義できます。また、サブセットに基づいて定義することもできます。</span><span class="sxs-lookup"><span data-stu-id="44b5a-105">You can base your definition of value equality on a comparison of all the fields and properties in the type, or you can base the definition on a subset.</span></span> <span data-ttu-id="44b5a-106">ただし、いずれの場合も、クラスおよび構造体の両方について、等価性を保証する 5 つの条件に従って実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="44b5a-106">But in either case, and in both classes and structs, your implementation should follow the five guarantees of equivalence:</span></span>  
  
1.  <span data-ttu-id="44b5a-107">`x.Equals(x)` は、`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="44b5a-107">`x.Equals(x)` returns `true`.</span></span> <span data-ttu-id="44b5a-108">これは再帰プロパティと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="44b5a-108">This is called the reflexive property.</span></span>  
  
2.  <span data-ttu-id="44b5a-109">`x.Equals(y)` からは `y.Equals(x)` と同じ値が返されます。</span><span class="sxs-lookup"><span data-stu-id="44b5a-109">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span> <span data-ttu-id="44b5a-110">これは対照プロパティと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="44b5a-110">This is called the symmetric property.</span></span>  
  
3.  <span data-ttu-id="44b5a-111">`(x.Equals(y) && y.Equals(z))` で `true` が返される場合、`x.Equals(z)` で `true` が返されます。</span><span class="sxs-lookup"><span data-stu-id="44b5a-111">if `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span> <span data-ttu-id="44b5a-112">これは推移的プロパティと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="44b5a-112">This is called the transitive property.</span></span>  
  
4.  <span data-ttu-id="44b5a-113">`x.Equals(y)` が連続して呼び出された場合は、x と y によって参照されるオブジェクトが変更されていない限り、同じ値を返します。</span><span class="sxs-lookup"><span data-stu-id="44b5a-113">Successive invocations of `x.Equals(y)` return the same value as long as the objects referenced by x and y are not modified.</span></span>  
  
5.  <span data-ttu-id="44b5a-114">`x.Equals(null)` は、`false` を返します。</span><span class="sxs-lookup"><span data-stu-id="44b5a-114">`x.Equals(null)` returns `false`.</span></span> <span data-ttu-id="44b5a-115">ただし、`null.Equals(null)` は例外をスローするため、上の 2 番目の規則には従っていません。</span><span class="sxs-lookup"><span data-stu-id="44b5a-115">However, `null.Equals(null)` throws an exception; it does not obey rule number two above.</span></span>  
  
 <span data-ttu-id="44b5a-116">構造体を定義すると、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドの <xref:System.ValueType?displayProperty=nameWithType> オーバーライドから継承された値の等価性が既定で実装されます。</span><span class="sxs-lookup"><span data-stu-id="44b5a-116">Any struct that you define already has a default implementation of value equality that it inherits from the <xref:System.ValueType?displayProperty=nameWithType> override of the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="44b5a-117">この実装では、リフレクションを使用して、型のフィールドとプロパティをすべて調べます。</span><span class="sxs-lookup"><span data-stu-id="44b5a-117">This implementation uses reflection to examine all the fields and properties in the type.</span></span> <span data-ttu-id="44b5a-118">この実装によって正しい結果が生成されますが、その型専用に記述したカスタム実装と比較すると、処理にかなり時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="44b5a-118">Although this implementation produces correct results, it is relatively slow compared to a custom implementation that you write specifically for the type.</span></span>  
  
 <span data-ttu-id="44b5a-119">値の等価性に関する実装の詳細は、クラスと構造体で異なりますが、</span><span class="sxs-lookup"><span data-stu-id="44b5a-119">The implementation details for value equality are different for classes and structs.</span></span> <span data-ttu-id="44b5a-120">等価性を実装するための基本的な手順については、両方とも同じです。</span><span class="sxs-lookup"><span data-stu-id="44b5a-120">However, both classes and structs require the same basic steps for implementing equality:</span></span>  
  
1.  <span data-ttu-id="44b5a-121">[仮想](../../../csharp/language-reference/keywords/virtual.md) <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="44b5a-121">Override the [virtual](../../../csharp/language-reference/keywords/virtual.md) <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="44b5a-122">ほとんどの場合、`bool Equals( object obj )` の実装には、<xref:System.IEquatable%601?displayProperty=nameWithType> インターフェイスの実装である型固有の `Equals` メソッドを呼び出すだけで済みます </span><span class="sxs-lookup"><span data-stu-id="44b5a-122">In most cases, your implementation of `bool Equals( object obj )` should just call into the type-specific `Equals` method that is the implementation of the <xref:System.IEquatable%601?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="44b5a-123">(手順 2 を参照)。</span><span class="sxs-lookup"><span data-stu-id="44b5a-123">(See step 2.)</span></span>  
  
2.  <span data-ttu-id="44b5a-124">型固有の `Equals` メソッドを指定して、<xref:System.IEquatable%601?displayProperty=nameWithType> インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="44b5a-124">Implement the <xref:System.IEquatable%601?displayProperty=nameWithType> interface by providing a type-specific `Equals` method.</span></span> <span data-ttu-id="44b5a-125">ここで実際の等価性の比較を実行します。</span><span class="sxs-lookup"><span data-stu-id="44b5a-125">This is where the actual equivalence comparison is performed.</span></span> <span data-ttu-id="44b5a-126">たとえば、型のフィールドを 1 ～ 2 個だけ比較することで等価性を定義できます。</span><span class="sxs-lookup"><span data-stu-id="44b5a-126">For example, you might decide to define equality by comparing only one or two fields in your type.</span></span> <span data-ttu-id="44b5a-127">`Equals` から例外をスローしないでください。</span><span class="sxs-lookup"><span data-stu-id="44b5a-127">Do not throw exceptions from `Equals`.</span></span> <span data-ttu-id="44b5a-128">クラスの場合に限り、このメソッドはクラスで宣言されているフィールドのみを調べます。</span><span class="sxs-lookup"><span data-stu-id="44b5a-128">For classes only: This method should examine only fields that are declared in the class.</span></span> <span data-ttu-id="44b5a-129">基底クラスに含まれるフィールドを調べるには、`base.Equals` を呼び出す必要があります </span><span class="sxs-lookup"><span data-stu-id="44b5a-129">It should call `base.Equals` to examine fields that are in the base class.</span></span> <span data-ttu-id="44b5a-130">(<xref:System.Object> から型が直接継承された場合は、この呼び出しを行わないでください。<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> の <xref:System.Object> 実装では参照の等価性チェックが実行されるためです)。</span><span class="sxs-lookup"><span data-stu-id="44b5a-130">(Do not do this if the type inherits directly from <xref:System.Object>, because the <xref:System.Object> implementation of <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> performs a reference equality check.)</span></span>  
  
3.  <span data-ttu-id="44b5a-131">推奨、ただし省略可能: [==](../../../csharp/language-reference/operators/equality-comparison-operator.md) 演算子および [!=](../../../csharp/language-reference/operators/not-equal-operator.md) 演算子をオーバーロードします。</span><span class="sxs-lookup"><span data-stu-id="44b5a-131">Optional but recommended: Overload the [==](../../../csharp/language-reference/operators/equality-comparison-operator.md) and [!=](../../../csharp/language-reference/operators/not-equal-operator.md) operators.</span></span>  
  
4.  <span data-ttu-id="44b5a-132">値の等価性を持つ 2 つのオブジェクトによって同じハッシュ コードが生成されるように、<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="44b5a-132">Override <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> so that two objects that have value equality produce the same hash code.</span></span>  
  
5.  <span data-ttu-id="44b5a-133">省略可能: "大なり" または "小なり" の定義をサポートするには、型に対して <xref:System.IComparable%601> インターフェイスを実装したうえで、[<=](../../../csharp/language-reference/operators/less-than-equal-operator.md) 演算子および [>=](../../../csharp/language-reference/operators/greater-than-equal-operator.md) 演算子をオーバーロードします。</span><span class="sxs-lookup"><span data-stu-id="44b5a-133">Optional: To support definitions for "greater than" or "less than," implement the <xref:System.IComparable%601> interface for your type, and also overload the [<=](../../../csharp/language-reference/operators/less-than-equal-operator.md) and [>=](../../../csharp/language-reference/operators/greater-than-equal-operator.md) operators.</span></span>  
  
 <span data-ttu-id="44b5a-134">次に示す最初の例は、クラスの実装です。</span><span class="sxs-lookup"><span data-stu-id="44b5a-134">The first example that follows shows a class implementation.</span></span> <span data-ttu-id="44b5a-135">2 番目の例は、構造体の実装を示しています。</span><span class="sxs-lookup"><span data-stu-id="44b5a-135">The second example shows a struct implementation.</span></span>  
  
## <a name="example"></a><span data-ttu-id="44b5a-136">例</span><span class="sxs-lookup"><span data-stu-id="44b5a-136">Example</span></span>  
 <span data-ttu-id="44b5a-137">次の例は、クラス (参照型) で値の等価性を実装する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="44b5a-137">The following example shows how to implement value equality in a class (reference type).</span></span>  
  
 [!code-csharp[csProgGuideStatements#19](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/how-to-define-value-equality-for-a-type_1.cs)]  
  
 <span data-ttu-id="44b5a-138">クラス (参照型) の場合、両方の <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> メソッドの既定の実装で、参照の等価性の比較は実行されますが、値の等価性のチェックは実行されません。</span><span class="sxs-lookup"><span data-stu-id="44b5a-138">On classes (reference types), the default implementation of both <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> methods performs a reference equality comparison, not a value equality check.</span></span> <span data-ttu-id="44b5a-139">実装が仮想メソッドをオーバーライドする場合、その目的は、仮想メソッドに値の等価性のセマンティクスを提供することです。</span><span class="sxs-lookup"><span data-stu-id="44b5a-139">When an implementer overrides the virtual method, the purpose is to give it value equality semantics.</span></span>  
  
 <span data-ttu-id="44b5a-140">`==` 演算子と `!=` 演算子は、オーバーロードされなくてもクラスで使用できます。</span><span class="sxs-lookup"><span data-stu-id="44b5a-140">The `==` and `!=` operators can be used with classes even if the class does not overload them.</span></span> <span data-ttu-id="44b5a-141">ただし、既定の動作として参照の等価性のチェックが実行されます。</span><span class="sxs-lookup"><span data-stu-id="44b5a-141">However, the default behavior is to perform a reference equality check.</span></span> <span data-ttu-id="44b5a-142">クラスで `Equals` メソッドをオーバーロードする場合は、`==` 演算子と `!=` 演算子をオーバーロードすることをお勧めしますが、必須ではありません。</span><span class="sxs-lookup"><span data-stu-id="44b5a-142">In a class, if you overload the `Equals` method, you should overload the `==` and `!=` operators, but it is not required.</span></span>  
  
## <a name="example"></a><span data-ttu-id="44b5a-143">例</span><span class="sxs-lookup"><span data-stu-id="44b5a-143">Example</span></span>  
 <span data-ttu-id="44b5a-144">次の例は、構造体 (値型) で値の等価性を実装する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="44b5a-144">The following example shows how to implement value equality in a struct (value type):</span></span>  
  
 [!code-csharp[csProgGuideStatements#20](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/how-to-define-value-equality-for-a-type_2.cs)]  
  
 <span data-ttu-id="44b5a-145">構造体の場合、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> (<xref:System.ValueType?displayProperty=nameWithType> でオーバーライドされるバージョン) の既定の実装で、リフレクションを使用して値の等価性のチェックが実行され、型のすべてのフィールドの値が比較されます。</span><span class="sxs-lookup"><span data-stu-id="44b5a-145">For structs, the default implementation of <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> (which is the overridden version in <xref:System.ValueType?displayProperty=nameWithType>) performs a value equality check by using reflection to compare the values of every field in the type.</span></span> <span data-ttu-id="44b5a-146">実装が構造体の仮想 `Equals` メソッドをオーバーライドする場合、その目的は、値の等価性のチェックをより効率的に実行することと、オプションで、構造体のフィールドまたはプロパティの一部のサブセットに基づいて比較を行うことです。</span><span class="sxs-lookup"><span data-stu-id="44b5a-146">When an implementer overrides the virtual `Equals` method in a struct, the purpose is to provide a more efficient means of performing the value equality check and optionally to base the comparison on some subset of the struct's field or properties.</span></span>  
  
 <span data-ttu-id="44b5a-147">[==](../../../csharp/language-reference/operators/equality-comparison-operator.md) 演算子および [!=](../../../csharp/language-reference/operators/not-equal-operator.md) 演算子は、構造体が明示的にその演算子をオーバーロードしない限り、その構造体を操作できません。</span><span class="sxs-lookup"><span data-stu-id="44b5a-147">The [==](../../../csharp/language-reference/operators/equality-comparison-operator.md) and [!=](../../../csharp/language-reference/operators/not-equal-operator.md) operators cannot operate on a struct unless the struct explicitly overloads them.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="44b5a-148">参照</span><span class="sxs-lookup"><span data-stu-id="44b5a-148">See Also</span></span>

- [<span data-ttu-id="44b5a-149">等価比較</span><span class="sxs-lookup"><span data-stu-id="44b5a-149">Equality Comparisons</span></span>](../../../csharp/programming-guide/statements-expressions-operators/equality-comparisons.md)  
- [<span data-ttu-id="44b5a-150">C# プログラミングガイド</span><span class="sxs-lookup"><span data-stu-id="44b5a-150">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)
